#summary Mini-OS现有应用介绍

Mini-OS是跟随Xen hypervisor发布的一款小内核操作系统，目前有一些基于Mini-OS的应用：HP实验室在2007年发布了基于Mini-OS的Xen Library OS；2008年剑桥大学进一步完善了HP的工作，完成了HVM stubdom并置于Xen源码树中；伊利诺伊大学芝加哥分校(UIC)正致力于开发一款基于Mini-OS的小内核系统—Ethos。

= Mini-OS启动简介 =

Mini-OS 在*start* 处启动，加载SS和ESP指向的地址。KERNEL_SS由Xen的GDT提供，ESP指向的地址取自于*stack_start* 。ESI寄存器指向Mini-OS的*start_info_t* 结构体。ESI做为参数传入到启动函数*start_kerel()* 中。

*start_kerel()* 是启动Mini-OS的例程。它调用了一些初始化函数，然后建立了三个内核线程。由于Mini-OS是不可抢占的并只能运行单线程的操作系统，所以这三个内核线程依次被创建。

== arch_init() ==

 * 将start_info数据结构拷贝到内核映像的一片全局区中(start_info_union.start_info)
 * 将全局变量phys_to_machine_mapping(mm.c)指向现有的P2M表(start_info.mfn_list)
 * 使用hypercall：HYPERVISOR_update_va_mapping把shared_info页映射到0x2000
 * 注册回调句柄(callback handlers)
{{{
// 通过set_callbacks()，注册各种event和failsafe的处理函数
set_callbacks(unsigned long event_selector, unsigned long event_address, unsigned long failsafe_selector, unsigned long failsafe_address)
}}}

== trap_init() ==

注册陷阱表(trap handler table)，通常定义于Mini-OS的arch/x86/x86_32.h中。
{{{
void trap_init(void)
{
    HYPERVISOR_set_trap_table(trap_table);
}
}}}

== init_mm() ==

该例程初始化Mini-OS的内存管理功能。
 * arch_init_mm()
  首先计算Mini-OS可以使用的页帧数。在Mini-OS中，text段起始于0x00，虚拟地址和客户物理地址是一致的。
然后调用build_pagetables(start_pfg,max_pfn)，建立页表。每增加一个页表项，调用HYPERVISOR_mmu_update()同步到hypervisor中。
 * arch_init_p2m()
  初始化HYPERVISOR_shared_info->arch.pfg_to_mfn_frame_list结构体，它记录了客户机页帧到物理机页帧的映射。
 * arch_init_demand_mapping_area()
  创建一个额外的PTE，可以用来按需地映射max_pfn之上的页地址。