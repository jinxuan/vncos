#summary Mini-OS现有应用介绍

Mini-OS是跟随Xen hypervisor发布的一款小内核操作系统，目前有一些基于Mini-OS的应用：HP实验室在2007年发布了基于Mini-OS的Xen Library OS；2008年剑桥大学进一步完善了HP的工作，完成了HVM stubdom并置于Xen源码树中；伊利诺伊大学芝加哥分校(UIC)正致力于开发一款基于Mini-OS的小内核系统—Ethos。

= Mini-OS启动简介 =

Mini-OS 在*start* 处启动，加载SS和ESP指向的地址。KERNEL_SS由Xen的GDT提供，ESP指向的地址取自于*stack_start* 。ESI寄存器指向Mini-OS的*start_info_t* 结构体。ESI做为参数传入到启动函数*start_kerel()* 中。

*start_kerel()* 是启动Mini-OS的例程。它调用了一些初始化函数，然后建立了三个内核线程。由于Mini-OS是不可抢占的并只能运行单线程的操作系统，所以这三个内核线程依次被创建。

== arch_init() ==

 * 将start_info数据结构拷贝到内核映像的一片全局区中(start_info_union.start_info)
 * 将全局变量phys_to_machine_mapping(mm.c)指向现有的P2M表(start_info.mfn_list)
 * 使用hypercall：HYPERVISOR_update_va_mapping把shared_info页映射到0x2000
 * 注册回调句柄(callback handlers)
{{{
// 通过set_callbacks()，注册各种event和failsafe的处理函数
set_callbacks(unsigned long event_selector, unsigned long event_address, unsigned long failsafe_selector, unsigned long failsafe_address)
}}}

== trap_init() ==

注册陷阱表(trap handler table)，通常定义于Mini-OS的arch/x86/x86_32.h中。
{{{
void trap_init(void)
{
    HYPERVISOR_set_trap_table(trap_table);
}
}}}

== init_mm() ==

该例程初始化Mini-OS的内存管理功能。

 * arch_init_mm()
  首先计算Mini-OS可以使用的页帧数。在Mini-OS中，text段起始于0x00，虚拟地址和客户物理地址是一致的。然后调用build_pagetables(start_pfg,max_pfn)，建立页表。每增加一个页表项，调用HYPERVISOR_mmu_update()同步到hypervisor中。
 * arch_init_p2m()
  初始化HYPERVISOR_shared_info->arch.pfg_to_mfn_frame_list结构体，它记录了客户机页帧到物理机页帧的映射。
 * arch_init_demand_mapping_area()
  创建一个额外的PTE，可以用来按需地映射大于max_pfn页地址。

= Xen Library OS =

== Xen Library OS的设计与实现 ==

Xen Library OS 是一个类虚拟化的操作系统，它由四部分组成：

 * 一个基于GNU工具链的cross-development环境
 * Red Hat的newlib C库
 * Mini-OS内核
 * 域间通信机制IDC，基于Xen共享内存和时间通道实现

=== 开发工具链 ===

加入一个基于GNU工具链的cross-development环境，目的是获得最大的代码兼容性。Linux上的进程可以兼容的运行在Library OS上。通过修改GNU编译器和二进制工具来支持新的目标体系结构。Library OS的编译器称作i386-minios-gcc，它的头文件、库和加载器都被重写。

=== Library OS ===

Library OS使用Red Hat的newlib C库支持C程序。但需要修改newlib库以适应Library OS，比如一些函数fork、exec等都不能在新的目标体系结构中使用。
Library OS选择Mini-OS为其kernel，主要原因是Mini-OS有完善的支持Xen类虚拟化接口，Xen社区对其提供维护。
由于程序、库、内核都运行在一个地址空间中，所以Library OS适合运行小的可信服务，而不是一般的用户程序。

=== 域间通信IDC ===

IDC是由Xen的事件通道实现的，包含读写两个IO环。IDC做为一个内核模块，向上层应用暴漏6个接口。
 * Init:      初始化一个通道
 * Close:     关闭一个通道
 * Create:    允许用户向通道写数据，用户要有目标域的ID
 * Connect:   允许用户在通道中读数据
 * Write:     向通道中写
 * Read:      在通道中读