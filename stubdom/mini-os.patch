diff -Nur ../extras/mini-os/arch/ia64/arch.mk /root/extras/mini-os/arch/ia64/arch.mk
--- ../extras/mini-os/arch/ia64/arch.mk	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/arch.mk	2009-06-04 22:55:12.000000000 +0800
@@ -1,5 +1,3 @@
-# Build for Big Endian?
-BIGENDIAN ?= n
 
 ARCH_CFLAGS := -mfixed-range=f2-f5,f12-f15,f32-f127 -mconstant-gp
 ARCH_CFLAGS += -O2
@@ -9,12 +7,3 @@
 
 ARCH_LDFLAGS = -warn-common
 
-# Next lines are for big endian code !
-ifeq ($(BIGENDIAN),y)
-ARCH_CFLAGS += -mbig-endian -Wa,-mbe -Wa,-mlp64
-ARCH_CFLAGS += -DBIG_ENDIAN
-ARCH_ASFLAGS += -Wa,-mbe
-ARCH_ASFLAGS += -DBIG_ENDIAN
-ARCH_LDFLAGS = -EB -d
-endif
-
diff -Nur ../extras/mini-os/arch/ia64/common.c /root/extras/mini-os/arch/ia64/common.c
--- ../extras/mini-os/arch/ia64/common.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/common.c	2009-06-04 22:55:12.000000000 +0800
@@ -116,8 +116,8 @@
 {
 	struct callback_register event =
 	{
-		.type = SWAP(CALLBACKTYPE_event),
-		.address = SWAP((unsigned long)&hypervisor_callback),
+		.type = CALLBACKTYPE_event,
+		.address = (unsigned long)&hypervisor_callback,
 	};
 	HYPERVISOR_callback_op(CALLBACKOP_register, &event);
 }
@@ -126,46 +126,44 @@
 init_start_info(start_info_t* xen_start_info)
 {
 	/* Make a copy of the start_info structure */
-	start_info.nr_pages = SWAP(xen_start_info->nr_pages);
-	start_info.shared_info = SWAP(xen_start_info->shared_info);
-	start_info.flags = SWAP(xen_start_info->flags);
-	start_info.store_mfn = SWAP(xen_start_info->store_mfn);
-	start_info.store_evtchn	= SWAP(xen_start_info->store_evtchn);
-	start_info.console.domU.mfn = SWAP(xen_start_info->console.domU.mfn);
+	start_info.nr_pages = xen_start_info->nr_pages;
+	start_info.shared_info = xen_start_info->shared_info;
+	start_info.flags = xen_start_info->flags;
+	start_info.store_mfn = xen_start_info->store_mfn;
+	start_info.store_evtchn	= xen_start_info->store_evtchn;
+	start_info.console.domU.mfn = xen_start_info->console.domU.mfn;
 	start_info.console.domU.evtchn =
-				SWAP(xen_start_info->console.domU.evtchn);
-	start_info.pt_base = SWAP(xen_start_info->pt_base);
-	start_info.nr_pt_frames	= SWAP(xen_start_info->nr_pt_frames);
-	start_info.mfn_list = SWAP(xen_start_info->mfn_list);
-	start_info.mod_start = SWAP(xen_start_info->mod_start);
-	start_info.mod_len = SWAP(xen_start_info->mod_len);
+				xen_start_info->console.domU.evtchn;
+	start_info.pt_base = xen_start_info->pt_base;
+	start_info.nr_pt_frames	= xen_start_info->nr_pt_frames;
+	start_info.mfn_list = xen_start_info->mfn_list;
+	start_info.mod_start = xen_start_info->mod_start;
+	start_info.mod_len = xen_start_info->mod_len;
 }
 
 static void
 init_boot_params(void)
 {
-	ia64BootParamG.command_line = SWAP(ia64_boot_paramP->command_line);
-	ia64BootParamG.efi_systab = SWAP(ia64_boot_paramP->efi_systab);
-	ia64BootParamG.efi_memmap = SWAP(ia64_boot_paramP->efi_memmap);
-	ia64BootParamG.efi_memmap_size =
-				SWAP(ia64_boot_paramP->efi_memmap_size);
-	ia64BootParamG.efi_memdesc_size	=
-				SWAP(ia64_boot_paramP->efi_memdesc_size);
+	ia64BootParamG.command_line = ia64_boot_paramP->command_line;
+	ia64BootParamG.efi_systab = ia64_boot_paramP->efi_systab;
+	ia64BootParamG.efi_memmap = ia64_boot_paramP->efi_memmap;
+	ia64BootParamG.efi_memmap_size = ia64_boot_paramP->efi_memmap_size;
+	ia64BootParamG.efi_memdesc_size	= ia64_boot_paramP->efi_memdesc_size;
 	ia64BootParamG.efi_memdesc_version =
-				SWAP(ia64_boot_paramP->efi_memdesc_version);
+				ia64_boot_paramP->efi_memdesc_version;
 	ia64BootParamG.console_info.num_cols =
-				SWAP(ia64_boot_paramP->console_info.num_cols);
+				ia64_boot_paramP->console_info.num_cols;
 	ia64BootParamG.console_info.num_rows =
-				SWAP(ia64_boot_paramP->console_info.num_rows);
+				ia64_boot_paramP->console_info.num_rows;
 	ia64BootParamG.console_info.orig_x =
-				SWAP(ia64_boot_paramP->console_info.orig_x);
+				ia64_boot_paramP->console_info.orig_x;
 	ia64BootParamG.console_info.orig_y =
-				SWAP(ia64_boot_paramP->console_info.orig_y);
-	ia64BootParamG.fpswa = SWAP(ia64_boot_paramP->fpswa);
-	ia64BootParamG.initrd_start = SWAP(ia64_boot_paramP->initrd_start);
-	ia64BootParamG.initrd_size = SWAP(ia64_boot_paramP->initrd_size);
-	ia64BootParamG.domain_start = SWAP(ia64_boot_paramP->domain_start);
-	ia64BootParamG.domain_size = SWAP(ia64_boot_paramP->domain_size);
+				ia64_boot_paramP->console_info.orig_y;
+	ia64BootParamG.fpswa = ia64_boot_paramP->fpswa;
+	ia64BootParamG.initrd_start = ia64_boot_paramP->initrd_start;
+	ia64BootParamG.initrd_size = ia64_boot_paramP->initrd_size;
+	ia64BootParamG.domain_start = ia64_boot_paramP->domain_start;
+	ia64BootParamG.domain_size = ia64_boot_paramP->domain_size;
 
 	/*
 	 * Copy and parse the boot command line.
diff -Nur ../extras/mini-os/arch/ia64/debug.c /root/extras/mini-os/arch/ia64/debug.c
--- ../extras/mini-os/arch/ia64/debug.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/debug.c	2009-06-04 22:55:12.000000000 +0800
@@ -102,7 +102,6 @@
 
 typedef struct
 {
-#if !defined(BIG_ENDIAN)
 	uint64_t sof	:7;	/* 0-6 size of frame */
 	uint64_t sol	:7;	/* 7-13 size of locals (in + loc) */
 	uint64_t sor	:4;
@@ -111,16 +110,6 @@
 	uint64_t rrb_pr	:6;
 	uint64_t res	:25;	/* reserved */
 	uint64_t v	:1;	/* The v bit */
-#else /* !BIG_ENDIAN */
-	uint64_t v	:1;	/* The v bit */
-	uint64_t res	:25;	/* reserved */
-	uint64_t rrb_pr	:6;
-	uint64_t rrb_fr	:7;
-	uint64_t rrb_gr	:7;
-	uint64_t sor	:4;
-	uint64_t sol	:7;	/* 7-13 size of locals (in + loc) */
-	uint64_t sof	:7;	/* 0-6 size of frame */
-#endif /* BIG_ENDIAN */
 } ifs_t;
 
 void
diff -Nur ../extras/mini-os/arch/ia64/efi.c /root/extras/mini-os/arch/ia64/efi.c
--- ../extras/mini-os/arch/ia64/efi.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/efi.c	2009-06-04 22:55:12.000000000 +0800
@@ -49,13 +49,6 @@
 		printk("efi.getTime() failed\n");
 		return 0;
 	}
-
-#if defined(BIG_ENDIAN)
-	tmP->Year = SWAP(tmP->Year);
-	tmP->TimeZone = SWAP(tmP->TimeZone);
-	tmP->Nanosecond = SWAP(tmP->Nanosecond);
-#endif
-
 	return 1;
 }
 
@@ -65,17 +58,7 @@
 static int
 efi_guid_cmp(efi_guid_t* a_le, efi_guid_t* b)
 {
-#if defined(BIG_ENDIAN)
-	if(SWAP(a_le->Data1) != b->Data1)
-		return 1;
-	if(SWAP(a_le->Data2) != b->Data2)
-		return 1;
-	if(SWAP(a_le->Data3) != b->Data3)
-		return 1;
-	return memcmp(a_le->Data4, b->Data4, sizeof(uint8_t)*8);
-#else
 	return memcmp(a_le, b, sizeof(efi_guid_t));
-#endif
 }
 
 void
@@ -99,20 +82,20 @@
 	efiSysTableP = (efi_system_table_t*)__va(ia64BootParamG.efi_systab);
 	machineFwG.efi.efiSysTableP = efiSysTableP;
 	PRINT_BV("EfiSystemTable at: %p\n", efiSysTableP);
-	fwP = (uint16_t*) __va(SWAP(efiSysTableP->FirmwareVendor));
+	fwP = (uint16_t*) __va(efiSysTableP->FirmwareVendor);
 	if (fwP) {
 		for (i = 0; i < (int)sizeof(fwVendor) - 1 && *fwP; ++i)
-			fwVendor[i] = SWAP(*fwP++);
+			fwVendor[i] = *fwP++;
 		fwVendor[i] = '\0';
 	}
 	PRINT_BV("  EFI-FirmwareVendor        : %s\n", fwVendor);
 	PRINT_BV("  EFI-FirmwareRevision      : %d\n",
-		 SWAP(efiSysTableP->FirmwareRevision));
+		 efiSysTableP->FirmwareRevision);
 	PRINT_BV("  EFI-SystemTable-Revision  : %d.%d\n",
-		 SWAP(efiSysTableP->Hdr.Revision)>>16,
-		 SWAP(efiSysTableP->Hdr.Revision)&0xffff);
+		 efiSysTableP->Hdr.Revision >> 16,
+		 efiSysTableP->Hdr.Revision & 0xffff);
 	rsP = (efi_runtime_services_t*)
-		__va(SWAP(efiSysTableP->RuntimeServices));
+		__va(efiSysTableP->RuntimeServices);
 	mdcnt = ia64BootParamG.efi_memmap_size /
 		ia64BootParamG.efi_memdesc_size;
 	memdP = (efi_memory_descriptor_t*) __va(ia64BootParamG.efi_memmap);
@@ -123,10 +106,10 @@
 	     mdP = NextMemoryDescriptor(mdP, ia64BootParamG.efi_memdesc_size)) {
 		/* Relocate runtime memory segments for firmware. */
 		PRINT_BV("  %d. Type: %x  Attributes: 0x%lx\n",
-			 i, SWAP(mdP->Type), SWAP(mdP->Attribute));
+			 i, mdP->Type, mdP->Attribute);
 		PRINT_BV("     PhysStart: 0x%lx  NumPages: 0x%lx\n",
-			 SWAP(mdP->PhysicalStart), SWAP(mdP->NumberOfPages));
-		switch (SWAP(mdP->Type)) {
+			 mdP->PhysicalStart, mdP->NumberOfPages);
+		switch (mdP->Type) {
 			case EfiRuntimeServicesData:
 				PRINT_BV("     -> EfiRuntimeServicesData\n");
 				break;
@@ -139,18 +122,17 @@
 			case EfiConventionalMemory:
 				PRINT_BV("     -> EfiConventionalMemory\n");
 				PRINT_BV("        start: 0x%lx end: 0x%lx\n",
-					SWAP(mdP->PhysicalStart),
-					SWAP(mdP->PhysicalStart)+
-					SWAP(mdP->NumberOfPages)*EFI_PAGE_SIZE);
+					mdP->PhysicalStart,
+					mdP->PhysicalStart +
+					mdP->NumberOfPages * EFI_PAGE_SIZE);
 				if (numConvMem) {
 					printk("     Currently only one efi "
 						"memory chunk supported !!!\n");
 					break;
 				}
-				machineFwG.mach_mem_start =
-					SWAP(mdP->PhysicalStart);
+				machineFwG.mach_mem_start = mdP->PhysicalStart;
 				machineFwG.mach_mem_size =
-					SWAP(mdP->NumberOfPages)*EFI_PAGE_SIZE;
+					mdP->NumberOfPages * EFI_PAGE_SIZE;
 				numConvMem++;
 				break;
 			case EfiMemoryMappedIOPortSpace:
@@ -158,7 +140,7 @@
 				break;
 			case EfiPalCode:
                        		machineFwG.ia64_pal_base =
-					__va(SWAP(mdP->PhysicalStart));
+					__va(mdP->PhysicalStart);
 				PRINT_BV("     -> EfiPalCode\n"
 					 "        start : %p\n",
 					 machineFwG.ia64_pal_base);
@@ -170,12 +152,11 @@
 		 * virtual addressing and the efi runtime functions
 		 * may be called directly.
 		 */
-		if (SWAP(mdP->Attribute) & EFI_MEMORY_RUNTIME) {
-			if (SWAP(mdP->Attribute) & EFI_MEMORY_WB)
-				mdP->VirtualStart =
-					SWAP(__va(mdP->PhysicalStart));
+		if (mdP->Attribute & EFI_MEMORY_RUNTIME) {
+			if (mdP->Attribute & EFI_MEMORY_WB)
+				mdP->VirtualStart = __va(mdP->PhysicalStart);
 			else {
-				if (SWAP(mdP->Attribute) & EFI_MEMORY_UC)
+				if (mdP->Attribute & EFI_MEMORY_UC)
 					printk("efi_init: RuntimeMemory with "
 						"UC attribute !!!!!!\n");
 					/*
@@ -187,7 +168,7 @@
 	}
 	/* Now switch efi runtime stuff to virtual addressing. */
 	status = ia64_call_efi_physical(
-			(void*)__va(SWAP((uint64_t)rsP->SetVirtualAddressMap)),
+			(void*)__va((uint64_t)rsP->SetVirtualAddressMap),
 			ia64BootParamG.efi_memmap_size,
 			ia64BootParamG.efi_memdesc_size,
 			ia64BootParamG.efi_memdesc_version,
@@ -200,35 +181,35 @@
 	}
 	/* Getting efi function pointer for getEfiTime. */
 	machineFwG.efi.getTimeF =
-		(efi_get_time_t)__va(SWAP((uint64_t)rsP->GetTime));
+		(efi_get_time_t)__va((uint64_t)rsP->GetTime);
 	/* Getting efi function pointer for resetSystem. */
 	machineFwG.efi.resetSystemF =
-		(efi_reset_system_t)__va(SWAP((uint64_t)rsP->ResetSystem));
+		(efi_reset_system_t)__va((uint64_t)rsP->ResetSystem);
 
 	/* Scanning the Configuration table of the EfiSystemTable. */
 	PRINT_BV("NumberOfConfigTableEntries: %ld\n",
-		 SWAP(efiSysTableP->NumberOfTableEntries));
+		 efiSysTableP->NumberOfTableEntries);
 
 	confP = (efi_configuration_table_t*)
-			__va(SWAP(efiSysTableP->ConfigurationTable));
-	for (i = 0; i < SWAP(efiSysTableP->NumberOfTableEntries); i++) {
+			__va(efiSysTableP->ConfigurationTable);
+	for (i = 0; i < efiSysTableP->NumberOfTableEntries; i++) {
 		if (!efi_guid_cmp(&confP[i].VendorGuid, &sal)) {
 			machineFwG.ia64_sal_tableP = (sal_system_table_t*)
-				__va(SWAP((uint64_t) confP[i].VendorTable));
+				__va((uint64_t) confP[i].VendorTable);
 			PRINT_BV("  Found SalSystemTable at: 0x%lx\n",
 				 (uint64_t) machineFwG.ia64_sal_tableP);
 			continue;
 		}
 		if (!efi_guid_cmp(&confP[i].VendorGuid, &acpi)) {
 			machineFwG.ia64_efi_acpi_table =
-				__va(SWAP((uint64_t) confP[i].VendorTable));
+				__va((uint64_t) confP[i].VendorTable);
 			PRINT_BV("  Found AcpiTable at:      0x%lx\n",
 				 (uint64_t) machineFwG.ia64_efi_acpi_table);
 			continue;
 		}
 		if (!efi_guid_cmp(&confP[i].VendorGuid, &acpi20)) {
 			machineFwG.ia64_efi_acpi20_table =
-				__va(SWAP((uint64_t) confP[i].VendorTable));
+				__va((uint64_t) confP[i].VendorTable);
 			PRINT_BV("  Found Acpi20Table at:    0x%lx\n",
 				 (uint64_t) machineFwG.ia64_efi_acpi20_table);
 			continue;
diff -Nur ../extras/mini-os/arch/ia64/fw.S /root/extras/mini-os/arch/ia64/fw.S
--- ../extras/mini-os/arch/ia64/fw.S	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/fw.S	2009-06-04 22:55:12.000000000 +0800
@@ -155,11 +155,6 @@
 	ld8	r14=[in0],8		// function address
 	;;
 	ld8	gp=[in0]		// function gp value
-#if defined(BIG_ENDIAN)
-	mux1	r14=r14,@rev		// swap because mini-os is in BE
-	mov	ar.rsc=3
-	;;
-#endif
 	mov	out0=in1
 	mov	out1=in2
 	mov	out2=in3
@@ -167,19 +162,7 @@
 	mov	out4=in5
 	mov	b6=r14
 	;;
-#if defined(BIG_ENDIAN)
-	mux1	gp=gp,@rev		// swap because mini-os is in BE
-	rum IA64_PSR_BE
-	;;
-#endif
-
 	br.call.sptk.many rp=b6		// call EFI procedure
-
-#if defined(BIG_ENDIAN)
-	;;
-	sum IA64_PSR_BE
-	mov	ar.rsc=IA64_RSE_EAGER
-#endif
 	mov	gp=loc3			// restore kernel gp
 	mov	r14=loc2		// psr to restore mode
 	;;
@@ -227,16 +210,8 @@
 	mov	b0=palret
 	rsm	psr.i			// disable interrupts
 	;;
-#if defined(BIG_ENDIAN)
-	rum	IA64_PSR_BE		// set psr.be==0
-	;;
-#endif
 	br.cond.sptk b6			// call into firmware
 	;;
-#if defined(BIG_ENDIAN)
-	sum	IA64_PSR_BE		// set psr.be==1
-	;;
-#endif
 	ssm	psr.i			// enable interrupts
 	;;
 2:	mov	psr.l=psrsave
@@ -271,25 +246,9 @@
 	;;
 	ld8	gp=[in0]		// function gp value
 	;;
-#if defined(BIG_ENDIAN)
-	mux1	r14=r14,@rev		// swap if mini-os is in BE
-	mux1	gp=gp,@rev		// swap if mini-os is in BE
-#endif
-	;;
 	mov	b6=r14
-
-#if defined(BIG_ENDIAN)
-	rum	IA64_PSR_BE
-	;;
-#endif
-
 	br.call.sptk.many rp=b6		// call EFI procedure
 	
-#if defined(BIG_ENDIAN)
-	sum	IA64_PSR_BE
-	;;
-#endif
-	
 	mov	ar.pfs=loc0
 	mov	gp=loc1
 	mov	rp=loc2
diff -Nur ../extras/mini-os/arch/ia64/ia64.S /root/extras/mini-os/arch/ia64/ia64.S
--- ../extras/mini-os/arch/ia64/ia64.S	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/ia64.S	2009-06-04 22:55:12.000000000 +0800
@@ -205,10 +205,6 @@
 	START_INFO_PFN_ld	r14=[r15]	// load the start_info_pfn
 	add	r16=7, r0
 	;;
-#if defined(BIG_ENDIAN)
-	mux1	r14=r14,@rev		// swap because mini-os is in BE
-#endif
-	;;
 	shl	r15=r14,PAGE_SHIFT_XEN_16K	// pfn << PAGE_SHIFT_XEN_16K
 	shl	r16=r16,IA64_RR_IDX_POS		// (7<<IA64_RR_IDX_POS)
 	;;
diff -Nur ../extras/mini-os/arch/ia64/ivt.S /root/extras/mini-os/arch/ia64/ivt.S
--- ../extras/mini-os/arch/ia64/ivt.S	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/ivt.S	2009-06-04 22:55:12.000000000 +0800
@@ -87,11 +87,6 @@
 	;;
 	ld8	r21=[r21]		// XEN.ipsr
 	ld8	r22=[r22];;		// XEN.iip
-#if defined(BIG_ENDIAN)
-	mux1	r21=r21,@rev		// swap because mini-os is in BE
-	mux1	r22=r22,@rev		// swap because mini-os is in BE
-	;;
-#endif
 	add	r19=TF_IPSR,r18
 	add	r20=TF_IIP,r18
 	;;
@@ -129,10 +124,6 @@
 	//bsw.1		// switch to bank 1 for saving these registers.
 	movl r30=XSI_BANKNUM		// Switch to bank 1.
 	mov r31=1;;
-#if defined(BIG_ENDIAN)
-	mux1	r31=r31,@rev		// swap because mini-os is in BE
-	;;
-#endif
 	st4 [r30]=r31
 	;;
 	/*
@@ -143,38 +134,13 @@
 	movl r30=XSI_BANK1_R16;
 	movl r31=XSI_BANK1_R16+8;; 
 	ld8 r16=[r30],16; ld8 r17=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r16=r16,@rev; mux1 r17=r17,@rev;;
-#endif
 	ld8 r18=[r30],16; ld8 r19=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r18=r18,@rev; mux1 r19=r19,@rev;;
-#endif
 	ld8 r20=[r30],16; ld8 r21=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r20=r20,@rev; mux1 r21=r21,@rev;;
-#endif
 	ld8 r22=[r30],16; ld8 r23=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r22=r22,@rev; mux1 r23=r23,@rev;;
-#endif
 	ld8 r24=[r30],16; ld8 r25=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r24=r24,@rev; mux1 r25=r25,@rev;;
-#endif
 	ld8 r26=[r30],16; ld8 r27=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r26=r26,@rev; mux1 r27=r27,@rev;;
-#endif
 	ld8 r28=[r30],16; ld8 r29=[r31],16;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r28=r28,@rev; mux1 r29=r29,@rev;;
-#endif
 	ld8 r30=[r30]; ld8 r31=[r31];;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r30=r30,@rev; mux1 r31=r31,@rev;;
-#endif
-
 	add	r2=TF_GREG16,r14
 	add	r3=TF_GREG17,r14
 	;;
@@ -251,10 +217,6 @@
 	;;
 	ld8	r21=[r8]
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r21=r21,@rev
-	;;
-#endif
 	st8	[r19]=r21		// store cr.ifs
 	dep.z	r22=r21,0,38		// copy ifm part from ifs.ifm
 	;;
@@ -330,12 +292,6 @@
 	;;
 	ld8	r21=[r19]		// load cr.ipsr
 	ld8	r22=[r20]		// load cr.iip
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	;;
-	mux1	r21=r21,@rev
-	mux1	r22=r22,@rev
-	;;
-#endif
 	movl	r16=XSI_IPSR		// XEN !!
 	;;
 	st8	[r16]=r21,XSI_IIP_OFS-XSI_IPSR_OFS	// XEN.ipsr
@@ -353,9 +309,6 @@
 	ld8	r22=[r19]		// ndirty
 	;;
 	shl	r21=r22,16		// value for ar.rsc
-	//mov	r19=(MOS_IA64_RSC_BE << IA64_RSC_BE)
-	;;
-	or	r21=(MOS_IA64_RSC_BE << IA64_RSC_BE),r21
 	;;
 	mov	ar.rsc=r21		// setup for loadrs
 	;;
@@ -386,10 +339,6 @@
 	ld8	r21=[r19]		// load ar.pfs
 	ld8	r22=[r20]		// load cr.ifs
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r22=r22,@rev
-	;;
-#endif
 	add	r19=TF_RSC,r18
 	mov	ar.pfs=r21
 	st8	[r16]=r22		// XEN.ifs
@@ -429,10 +378,6 @@
 	// bsw.1
 	movl r30=XSI_BANKNUM		// Switch to bank 1.
 	mov r31=1;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r31=r31,@rev
-	;;
-#endif
 	st4 [r30]=r31
 	;;
 	add	r2=TF_GREG16,r14
@@ -455,51 +400,27 @@
 	movl r2=XSI_BANK1_R16
 	movl r3=XSI_BANK1_R16+8
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r16=r16,@rev; mux1 r17=r17,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r16,16
 	.mem.offset 8,0; st8.spill [r3]=r17,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r18=r18,@rev; mux1 r19=r19,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r18,16
 	.mem.offset 8,0; st8.spill [r3]=r19,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r20=r20,@rev; mux1 r21=r21,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r20,16
 	.mem.offset 8,0; st8.spill [r3]=r21,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r22=r22,@rev; mux1 r23=r23,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r22,16
 	.mem.offset 8,0; st8.spill [r3]=r23,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r24=r24,@rev; mux1 r25=r25,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r24,16
 	.mem.offset 8,0; st8.spill [r3]=r25,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r26=r26,@rev; mux1 r27=r27,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r26,16
 	.mem.offset 8,0; st8.spill [r3]=r27,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r28=r28,@rev; mux1 r29=r29,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r28,16
 	.mem.offset 8,0; st8.spill [r3]=r29,16
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r30=r30,@rev; mux1 r31=r31,@rev;;
-#endif
 	.mem.offset 0,0; st8.spill [r2]=r30,16
 	.mem.offset 8,0; st8.spill [r3]=r31,16
 	;;
@@ -567,17 +488,11 @@
 	add	loc5=TF_IFA,in0
 	add	loc6=TF_ISR,in0
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	loc3=loc3,@rev; mux1 loc4=loc4,@rev;;
-#endif
 	st8	[loc5]=loc3,TF_IIM-TF_IFA	// store cr.ifa
 	st8	[loc6]=loc4			// store cr.isr
 	;;
 	ld8	loc3=[loc1]			// load XEN.iim
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	loc3=loc3,@rev;;
-#endif
 	st8	[loc5]=loc3			// store cr.iim
 	;;
 	mov	ar.pfs=loc0
@@ -605,9 +520,6 @@
 	mov	out0=r18		// the trap frame
 	movl	r22=XSI_PSR_IC
 	mov	r23=1;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r23=r23,@rev;;
-#endif
 	st8	[r22]=r23		// ssm psr.ic
 	;;
 	br.call.sptk.few rp = do_hypervisor_callback
@@ -649,9 +561,6 @@
 	;;
 	movl r30=XSI_BANKNUM		// bsw.1
 	mov r31=1;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r31=r31,@rev;;
-#endif
 	st4 [r30]=r31;;
 
 		/* Save extra interrupt registers to the trap frame. */
@@ -664,9 +573,6 @@
 	ld8	r23=[r23]
 	mov	r25=1
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r25=r25,@rev; mux1 r23=r23,@rev;;
-#endif
 	st4	[r22]=r25		// ssm psr.ic
 	st1	[r23]=r0		// ssm psr.i
 	;;
@@ -680,10 +586,6 @@
 	ld8 r23=[r23]
 	mov r25=1
 	;;
-#if defined(BIG_ENDIAN)			// swap because mini-os is in BE
-	mux1	r25=r25,@rev;;
-	mux1	r25=r25,@rev; mux1 r23=r23,@rev;;
-#endif
 	st1 [r23]=r25
 	st4 [r22]=r0            // note: clears both vpsr.i and vpsr.ic!
 	;;
diff -Nur ../extras/mini-os/arch/ia64/minios-ia64.lds /root/extras/mini-os/arch/ia64/minios-ia64.lds
--- ../extras/mini-os/arch/ia64/minios-ia64.lds	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/minios-ia64.lds	2009-06-04 22:55:12.000000000 +0800
@@ -52,7 +52,8 @@
   .fini_array     : { *(.fini_array) }
   PROVIDE (__fini_array_end = .);
 
-  .ctors : {
+  .ctors : AT(ADDR(.ctors) - (((5<<(61))+0x100000000) - (1 << 20)))
+	{
         __CTOR_LIST__ = .;
         QUAD((__CTOR_END__ - __CTOR_LIST__) / 8 - 2)
         *(.ctors)
@@ -61,7 +62,8 @@
         __CTOR_END__ = .;
         }
 
-  .dtors : {
+  .dtors : AT(ADDR(.dtors) - (((5<<(61))+0x100000000) - (1 << 20)))
+        {
         __DTOR_LIST__ = .;
         QUAD((__DTOR_END__ - __DTOR_LIST__) / 8 - 2)
         *(.dtors)
diff -Nur ../extras/mini-os/arch/ia64/mm.c /root/extras/mini-os/arch/ia64/mm.c
--- ../extras/mini-os/arch/ia64/mm.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/mm.c	2009-06-04 22:55:12.000000000 +0800
@@ -153,7 +153,19 @@
         ASSERT(n == 1 || (stride == 0 && increment == 1));
         ASSERT(id == DOMID_SELF);
         ASSERT(prot == 0);
-	return (void*) __va(SWAP(frames[0]) << PAGE_SHIFT);
+	return (void*) __va(frames[0] << PAGE_SHIFT);
+}
+
+int unmap_frames(unsigned long virt_addr, unsigned long num_frames)
+{  
+    /* TODO */
+    ASSERT(0);
+}
+
+unsigned long alloc_contig_pages(int order, unsigned int addr_bits)
+{
+    /* TODO */
+    ASSERT(0);
 }
 
 void arch_init_p2m(unsigned long max_pfn)
diff -Nur ../extras/mini-os/arch/ia64/sal.c /root/extras/mini-os/arch/ia64/sal.c
--- ../extras/mini-os/arch/ia64/sal.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/sal.c	2009-06-04 22:55:12.000000000 +0800
@@ -76,19 +76,19 @@
 		return;
 	}
 	p = (uint8_t *) (saltab + 1);
-	for (i = 0; i < SWAP(saltab->sal_entry_count); i++) {
-		switch (SWAP(*p)) {
+	for (i = 0; i < saltab->sal_entry_count; i++) {
+		switch (*p) {
 		case SAL_DESC_ENTRYPOINT:		// 0
 		{
 			struct sal_entrypoint_descriptor *dp;
 
 			dp = (struct sal_entrypoint_descriptor*)p;
 			ia64_pal_entry =
-				IA64_PHYS_TO_RR7(SWAP(dp->sale_pal_proc));
+				IA64_PHYS_TO_RR7(dp->sale_pal_proc);
 			PRINT_BV("  PAL Proc at 0x%lx\n", ia64_pal_entry);
 			sal_fdesc.func =
-				IA64_PHYS_TO_RR7(SWAP(dp->sale_sal_proc));
-			sal_fdesc.gp = IA64_PHYS_TO_RR7(SWAP(dp->sale_sal_gp));
+				IA64_PHYS_TO_RR7(dp->sale_sal_proc);
+			sal_fdesc.gp = IA64_PHYS_TO_RR7(dp->sale_sal_gp);
 			PRINT_BV("  SAL Proc at 0x%lx, GP at 0x%lx\n",
 				 sal_fdesc.func, sal_fdesc.gp);
 			ia64_sal_entry = (sal_entry_t *) &sal_fdesc;
diff -Nur ../extras/mini-os/arch/ia64/time.c /root/extras/mini-os/arch/ia64/time.c
--- ../extras/mini-os/arch/ia64/time.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/time.c	2009-06-04 22:55:12.000000000 +0800
@@ -1,26 +1,9 @@
 /* 
  * Done by Dietmar Hahn <dietmar.hahn@fujitsu-siemens.com>
  * Description: simple ia64 specific time handling
- * mktime() is taken from Linux (see copyright below)
  * Parts are taken from FreeBSD.
  *
  ****************************************************************************
- * For the copy of the mktime() from linux.
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- ****************************************************************************
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -57,45 +40,73 @@
 static uint64_t processor_frequency;
 static uint64_t itm_val;
 
+static int is_leap_year(int year)
+{
+	if( year % 4 == 0 )
+	{
+		if( year % 100 == 0 )
+		{
+			if( year % 400 == 0 ) return 1;
+			else return 0;
+		}
+		return 1;
+	}
+	return 0;
+}
+
+static int count_leap_years(int epoch, int year)
+{
+	int i, result = 0;
+	for( i = epoch ; i < year ; i++ ) if( is_leap_year(i) ) result++;
+	return result;
+}
+
+static int get_day(int year, int mon, int day) {
+	int result;
+	switch(mon)
+	{
+		case 0: result = 0; break;
+		case 1: result = 31; break; /* 1: 31 */
+		case 2: result = 59; break; /* 2: 31+28 */
+		case 3: result = 90; break; /* 3: 59+31 */
+		case 4: result = 120;break; /* 4: 90+30 */
+		case 5: result = 151;break; /* 5: 120+31 */
+		case 6: result = 181;break; /* 6: 151+30 */
+		case 7: result = 212;break; /* 7: 181+31 */
+		case 8: result = 243;break; /* 8: 212+31 */
+		case 9: result = 273;break; /* 9: 243+30 */
+		case 10:result = 304;break; /* 10:273+31 */
+		case 11:result = 334;break; /* 11:304+30 */
+		default: break;
+	}
+	if( is_leap_year(year) && mon > 2 ) result++;
+	result += day - 1;
+	return result;
+}
 
 /*
- * mktime() is take from Linux. See copyright above.
  * Converts Gregorian date to seconds since 1970-01-01 00:00:00.
  * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
  * => year=1980, mon=12, day=31, hour=23, min=59, sec=59.
  *
- * [For the Julian calendar (which was used in Russia before 1917,
- * Britain & colonies before 1752, anywhere else before 1582,
- * and is still in use by some communities) leave out the
- * -year/100+year/400 terms, and add 10.]
- *
- * This algorithm was first published by Gauss (I think).
- *
  * WARNING: this function will overflow on 2106-02-07 06:28:16 on
  * machines were long is 32-bit! (However, as time_t is signed, we
  * will already get problems at other places on 2038-01-19 03:14:08)
  */
-static unsigned long
-_mktime(const unsigned int year0, const unsigned int mon0,
-       const unsigned int day, const unsigned int hour,
-       const unsigned int min, const unsigned int sec)
-{
-	unsigned int mon = mon0, year = year0;
-
-	/* 1..12 -> 11,12,1..10 */
-	if (0 >= (int) (mon -= 2)) {
-		mon += 12;	/* Puts Feb last since it has leap day */
-		year -= 1;
-	}
+static unsigned long _mktime(const unsigned int year, const unsigned int mon,
+			    const unsigned int day, const unsigned int hour,
+		            const unsigned int min, const unsigned int sec)
+{
+	unsigned long result = 0;
+
+	result = sec;
+	result += min * 60;
+	result += hour * 3600;
+	result += get_day(year, mon - 1, day) * 86400;
+	result += (year - 1970) * 31536000;
+	result += count_leap_years(1970, year) * 86400;
 
-	return (
-		(
-		 ((unsigned long)
-		  (year/4 - year/100 + year/400 + 367*mon/12 + day) +
-		   year*365 - 719499
-		 ) * 24 + hour /* now have hours */
-		) * 60 + min /* now have minutes */
-	       ) * 60 + sec; /* finally seconds */
+	return result;
 }
 
 static inline uint64_t
@@ -197,15 +208,6 @@
 	struct ia64_pal_result pal_res;
 
 	pal_res = ia64_call_pal_static(PAL_FREQ_RATIOS, 0, 0, 0);
-	//sal_res = ia64_sal_call(SAL_FREQ_BASE, 0, 0, 0, 0, 0, 0, 0);
-#if defined(BIG_ENDIAN)
-//#warning calculate_frequencies TODO
-	/*
-	 * I have to do an own function with switching psr.be!
-	 * Currently it's running because it's a break into the hypervisor
-	 * behind the call.!
-	 */
-#endif
 	sal_res = ia64_sal_entry(SAL_FREQ_BASE, 0, 0, 0, 0, 0, 0, 0);
 
 	if (sal_res.sal_status == 0 && pal_res.pal_status == 0) {
@@ -260,9 +262,8 @@
 	if (efi_get_time(&tm)) {
 		printk("  EFI-Time: %d.%d.%d   %d:%d:%d\n", tm.Day,
 		       tm.Month, tm.Year, tm.Hour, tm.Minute, tm.Second);
-		os_time.tv_sec = _mktime(SWAP(tm.Year), SWAP(tm.Month),
-					SWAP(tm.Day), SWAP(tm.Hour),
-					SWAP(tm.Minute), SWAP(tm.Second));
+		os_time.tv_sec = _mktime(tm.Year, tm.Month,
+					tm.Day, tm.Hour, tm.Minute, tm.Second);
 		os_time.tv_nsec = tm.Nanosecond;
 	} else
 		printk("efi_get_time() failed\n");
diff -Nur ../extras/mini-os/arch/ia64/xencomm.c /root/extras/mini-os/arch/ia64/xencomm.c
--- ../extras/mini-os/arch/ia64/xencomm.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/ia64/xencomm.c	2009-06-04 22:55:12.000000000 +0800
@@ -24,6 +24,8 @@
 
 
 #include <os.h>
+#include <mini-os/errno.h>
+#include <mini-os/lib.h>
 #include <hypervisor.h>
 #include <xen/xencomm.h>
 #include <xen/grant_table.h>
@@ -38,6 +40,7 @@
 
 #define xen_guest_handle(hnd)  ((hnd).p)
 
+struct xencomm_handle;
 
 /* Translate virtual address to physical address.  */
 uint64_t
@@ -52,6 +55,16 @@
 	return 0;
 }
 
+/* Inline version.  To be used only on linear space (kernel space).  */
+static struct xencomm_handle *
+xencomm_create_inline(void *buffer)
+{
+	unsigned long paddr;
+
+	paddr = xencomm_vaddr_to_paddr((unsigned long)buffer);
+	return (struct xencomm_handle *)(paddr | XENCOMM_INLINE_FLAG);
+}
+
 #define min(a,b) (((a) < (b)) ? (a) : (b))
 static int
 xencomm_init_desc(struct xencomm_desc *desc, void *buffer, unsigned long bytes)
@@ -82,7 +95,7 @@
 			return -EINVAL;
 		}
 
-		desc->address[i++] = SWAP(paddr);
+		desc->address[i++] = paddr;
 		recorded += chunksz;
 	}
 	if (recorded < bytes) {
@@ -93,8 +106,8 @@
 
 	/* mark remaining addresses invalid (just for safety) */
 	while (i < desc->nr_addrs)
-		desc->address[i++] = SWAP(XENCOMM_INVALID);
-	desc->magic = SWAP(XENCOMM_MAGIC);
+		desc->address[i++] = XENCOMM_INVALID;
+	desc->magic = XENCOMM_MAGIC;
 	return 0;
 }
 
@@ -171,15 +184,14 @@
 			return -EINVAL;
 		rc = xencomm_create_mini
 		        (xc_area, nbr_area,
-		         (void*)SWAP((uint64_t)
-				     xen_guest_handle(setup->frame_list)),
-		         SWAP(setup->nr_frames)
+		         (void*)(uint64_t) xen_guest_handle(setup->frame_list),
+		         setup->nr_frames
 		         * sizeof(*xen_guest_handle(setup->frame_list)),
 		         &desc1);
 		if (rc)
 			return rc;
 		set_xen_guest_handle(setup->frame_list,
-				     (void *)SWAP((uint64_t)desc1));
+				     (void *)(uint64_t)desc1);
 		break;
 	}
 	case GNTTABOP_dump_table:
@@ -201,6 +213,14 @@
 	return rc;
 }
 
+static inline int
+xencomm_arch_hypercall_grant_table_op(unsigned int cmd,
+                                      struct xencomm_handle *uop,
+                                      unsigned int count)
+{
+	return _hypercall3(int, grant_table_op, cmd, uop, count);
+}
+
 int
 xencomm_mini_hypercall_grant_table_op(unsigned int cmd, void *op,
                                       unsigned int count)
@@ -263,8 +283,112 @@
 {
         struct sched_shutdown arg;
 
-        arg.reason = (uint32_t)SWAP((uint32_t)SHUTDOWN_suspend);
+        arg.reason = (uint32_t)SHUTDOWN_suspend;
 
         return xencomm_arch_hypercall_suspend(xencomm_create_inline(&arg));
 }
 
+int
+HYPERVISOR_event_channel_op(int cmd, void *arg)
+{
+	int rc;
+	struct xencomm_handle *newArg;
+
+	newArg = xencomm_create_inline(arg);
+	rc = _hypercall2(int, event_channel_op, cmd, newArg);
+	if (unlikely(rc == -ENOSYS)) {
+		struct evtchn_op op;
+
+		op.cmd = cmd;
+		memcpy(&op.u, arg, sizeof(op.u));
+		rc = _hypercall1(int, event_channel_op_compat, &op);
+	}
+	return rc;
+}
+
+static int
+xencomm_arch_xen_version(int cmd, struct xencomm_handle *arg)
+{
+	return _hypercall2(int, xen_version, cmd, arg);
+}
+
+static int
+xencomm_arch_xen_feature(int cmd, struct xencomm_handle *arg)
+{
+	struct xencomm_handle *newArg;
+
+	newArg = xencomm_create_inline(arg);
+	return _hypercall2(int, xen_version, cmd, newArg);
+}
+
+int
+HYPERVISOR_xen_version(int cmd, void *arg)
+{
+	switch(cmd) {
+		case XENVER_version:
+			return xencomm_arch_xen_version(cmd, 0);
+		case XENVER_get_features:
+			return xencomm_arch_xen_feature(cmd, arg);
+		default:
+			return -1;
+	}
+}
+
+int
+HYPERVISOR_console_io(int cmd, int count, char *str)
+{
+	struct xencomm_handle *newStr;
+
+	newStr = xencomm_create_inline(str);
+	return _hypercall3(int, console_io, cmd, count, newStr);
+}
+
+int
+HYPERVISOR_sched_op_compat(int cmd, unsigned long arg)
+{
+	return _hypercall2(int, sched_op_compat, cmd, arg);
+}
+
+int
+HYPERVISOR_sched_op(int cmd, void *arg)
+{
+	struct xencomm_handle *newArg;
+
+	newArg = xencomm_create_inline(arg);
+	return _hypercall2(int, sched_op, cmd, newArg);
+}
+
+int
+HYPERVISOR_callback_op(int cmd, void *arg)
+{
+	struct xencomm_handle *newArg;
+
+	newArg = xencomm_create_inline(arg);
+	return _hypercall2(int, callback_op, cmd, newArg);
+}
+
+int
+HYPERVISOR_opt_feature(void *arg)
+{
+	struct xencomm_handle *new_arg;
+
+	new_arg = xencomm_create_inline(arg);
+
+	return _hypercall1(int, opt_feature, new_arg);
+}
+
+int
+HYPERVISOR_shutdown(unsigned int reason)
+{
+	struct sched_shutdown sched_shutdown = {
+		.reason = reason
+	};
+
+	int rc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &sched_shutdown);
+
+	if (rc == -ENOSYS)
+		rc = HYPERVISOR_sched_op_compat(SCHEDOP_shutdown, reason);
+
+	return rc;
+}
+
diff -Nur ../extras/mini-os/arch/x86/ioremap.c /root/extras/mini-os/arch/x86/ioremap.c
--- ../extras/mini-os/arch/x86/ioremap.c	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/arch/x86/ioremap.c	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2009,  Netronome Systems, Inc.
+ *                
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+
+#include <types.h>
+#include <lib.h>
+#include <xmalloc.h>
+#include <mm.h>
+#include <ioremap.h>
+
+/* Map a physical address range into virtual address space with provided
+ * flags. Return a virtual address range it is mapped to. */
+static void *__do_ioremap(unsigned long phys_addr, unsigned long size, 
+                          unsigned long prot)
+{
+    unsigned long va;
+    unsigned long mfns, mfn;
+    unsigned long num_pages, offset;
+    int i;
+
+    /* allow non page aligned addresses but for mapping we need to align them */
+    offset = (phys_addr & ~PAGE_MASK);
+    num_pages = (offset + size + PAGE_SIZE - 1) / PAGE_SIZE;
+    phys_addr &= PAGE_MASK;
+    mfns = mfn = phys_addr >> PAGE_SHIFT;
+    
+    /* sanity checks on list of MFNs */
+    for ( i = 0; i < num_pages; i++, mfn++ )
+    {
+        if ( mfn_is_ram(mfn) )
+        {
+            printk("ioremap: mfn 0x%ulx is RAM\n", mfn);
+            goto mfn_invalid;
+        }
+    }   
+    va = (unsigned long)map_frames_ex(&mfns, num_pages, 0, 1, 1,
+                                      DOMID_IO, 0, prot);
+    return (void *)(va + offset);
+    
+mfn_invalid:
+    return NULL;
+}
+
+void *ioremap(unsigned long phys_addr, unsigned long size)
+{
+    return __do_ioremap(phys_addr, size, IO_PROT);
+}
+
+void *ioremap_nocache(unsigned long phys_addr, unsigned long size)
+{
+    return __do_ioremap(phys_addr, size, IO_PROT_NOCACHE);
+}
+
+/* Un-map the io-remapped region. Currently no list of existing mappings is
+ * maintained, so the caller has to supply the size */
+void iounmap(void *virt_addr, unsigned long size)
+{   
+    unsigned long num_pages;
+    unsigned long va = (unsigned long)virt_addr;
+
+    /* work out number of frames to unmap */
+    num_pages = ((va & ~PAGE_MASK) + size + PAGE_SIZE - 1) / PAGE_SIZE;
+
+    unmap_frames(va & PAGE_MASK, num_pages);
+}
+
+
+
+/* -*-  Mode:C; c-basic-offset:4; tab-width:4 indent-tabs-mode:nil -*- */
diff -Nur ../extras/mini-os/arch/x86/mm.c /root/extras/mini-os/arch/x86/mm.c
--- ../extras/mini-os/arch/x86/mm.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/x86/mm.c	2009-06-04 22:55:12.000000000 +0800
@@ -52,20 +52,26 @@
 unsigned long *phys_to_machine_mapping;
 unsigned long mfn_zero;
 extern char stack[];
-extern void page_walk(unsigned long virt_addr);
+extern void page_walk(unsigned long va);
 
-void new_pt_frame(unsigned long *pt_pfn, unsigned long prev_l_mfn, 
-                                unsigned long offset, unsigned long level)
+/*
+ * Make pt_pfn a new 'level' page table frame and hook it into the page
+ * table at offset in previous level MFN (pref_l_mfn). pt_pfn is a guest
+ * PFN.
+ */
+static void new_pt_frame(unsigned long *pt_pfn, unsigned long prev_l_mfn, 
+                         unsigned long offset, unsigned long level)
 {   
     pgentry_t *tab = (pgentry_t *)start_info.pt_base;
     unsigned long pt_page = (unsigned long)pfn_to_virt(*pt_pfn); 
     pgentry_t prot_e, prot_t;
     mmu_update_t mmu_updates[1];
+    int rc;
     
     prot_e = prot_t = 0;
-    DEBUG("Allocating new L%d pt frame for pt_pfn=%lx, "
-           "prev_l_mfn=%lx, offset=%lx", 
-           level, *pt_pfn, prev_l_mfn, offset);
+    DEBUG("Allocating new L%d pt frame for pfn=%lx, "
+          "prev_l_mfn=%lx, offset=%lx", 
+          level, *pt_pfn, prev_l_mfn, offset);
 
     /* We need to clear the page, otherwise we might fail to map it
        as a page table page */
@@ -74,56 +80,63 @@
     switch ( level )
     {
     case L1_FRAME:
-         prot_e = L1_PROT;
-         prot_t = L2_PROT;
-         break;
+        prot_e = L1_PROT;
+        prot_t = L2_PROT;
+        break;
     case L2_FRAME:
-         prot_e = L2_PROT;
-         prot_t = L3_PROT;
-         break;
+        prot_e = L2_PROT;
+        prot_t = L3_PROT;
+        break;
 #if defined(__x86_64__)
     case L3_FRAME:
-         prot_e = L3_PROT;
-         prot_t = L4_PROT;
-         break;
+        prot_e = L3_PROT;
+        prot_t = L4_PROT;
+        break;
 #endif
     default:
-         printk("new_pt_frame() called with invalid level number %d\n", level);
-         do_exit();
-         break;
+        printk("new_pt_frame() called with invalid level number %d\n", level);
+        do_exit();
+        break;
     }
 
-    /* Update the entry */
+    /* Make PFN a page table page */
 #if defined(__x86_64__)
     tab = pte_to_virt(tab[l4_table_offset(pt_page)]);
 #endif
     tab = pte_to_virt(tab[l3_table_offset(pt_page)]);
 
     mmu_updates[0].ptr = (tab[l2_table_offset(pt_page)] & PAGE_MASK) + 
-                         sizeof(pgentry_t) * l1_table_offset(pt_page);
+        sizeof(pgentry_t) * l1_table_offset(pt_page);
     mmu_updates[0].val = (pgentry_t)pfn_to_mfn(*pt_pfn) << PAGE_SHIFT | 
-                         (prot_e & ~_PAGE_RW);
-    if(HYPERVISOR_mmu_update(mmu_updates, 1, NULL, DOMID_SELF) < 0)
+        (prot_e & ~_PAGE_RW);
+    
+    if ( (rc = HYPERVISOR_mmu_update(mmu_updates, 1, NULL, DOMID_SELF)) < 0 )
     {
-         printk("PTE for new page table page could not be updated\n");
-         do_exit();
+        printk("ERROR: PTE for new page table page could not be updated\n");
+        printk("       mmu_update failed with rc=%d\n", rc);
+        do_exit();
     }
-                        
-    /* Now fill the new page table page with entries.
-       Update the page directory as well. */
-    mmu_updates[0].ptr = ((pgentry_t)prev_l_mfn << PAGE_SHIFT) + sizeof(pgentry_t) * offset;
+
+    /* Hook the new page table page into the hierarchy */
+    mmu_updates[0].ptr =
+        ((pgentry_t)prev_l_mfn << PAGE_SHIFT) + sizeof(pgentry_t) * offset;
     mmu_updates[0].val = (pgentry_t)pfn_to_mfn(*pt_pfn) << PAGE_SHIFT | prot_t;
-    if(HYPERVISOR_mmu_update(mmu_updates, 1, NULL, DOMID_SELF) < 0) 
+
+    if ( (rc = HYPERVISOR_mmu_update(mmu_updates, 1, NULL, DOMID_SELF)) < 0 ) 
     {
-       printk("ERROR: mmu_update failed\n");
-       do_exit();
+        printk("ERROR: mmu_update failed with rc=%d\n", rc);
+        do_exit();
     }
 
     *pt_pfn += 1;
 }
 
-/* Checks if a pagetable frame is needed (if weren't allocated by Xen) */
-static int need_pt_frame(unsigned long virt_address, int level)
+/*
+ * Checks if a pagetable frame is needed at 'level' to map a given
+ * address. Note, this function is specific to the initial page table
+ * building.
+ */
+static int need_pt_frame(unsigned long va, int level)
 {
     unsigned long hyp_virt_start = HYPERVISOR_VIRT_START;
 #if defined(__x86_64__)
@@ -135,63 +148,71 @@
     /* In general frames will _not_ be needed if they were already
        allocated to map the hypervisor into our VA space */
 #if defined(__x86_64__)
-    if(level == L3_FRAME)
+    if ( level == L3_FRAME )
     {
-        if(l4_table_offset(virt_address) >= 
-           l4_table_offset(hyp_virt_start) &&
-           l4_table_offset(virt_address) <= 
-           l4_table_offset(hyp_virt_end))
+        if ( l4_table_offset(va) >= 
+             l4_table_offset(hyp_virt_start) &&
+             l4_table_offset(va) <= 
+             l4_table_offset(hyp_virt_end))
             return 0;
         return 1;
-    } else
+    } 
+    else
 #endif
 
-    if(level == L2_FRAME)
+    if ( level == L2_FRAME )
     {
 #if defined(__x86_64__)
-        if(l4_table_offset(virt_address) >= 
-           l4_table_offset(hyp_virt_start) &&
-           l4_table_offset(virt_address) <= 
-           l4_table_offset(hyp_virt_end))
-#endif
-            if(l3_table_offset(virt_address) >= 
-               l3_table_offset(hyp_virt_start) &&
-               l3_table_offset(virt_address) <= 
-               l3_table_offset(hyp_virt_end))
+        if ( l4_table_offset(va) >= 
+             l4_table_offset(hyp_virt_start) &&
+             l4_table_offset(va) <= 
+             l4_table_offset(hyp_virt_end))
+#endif
+            if ( l3_table_offset(va) >= 
+                 l3_table_offset(hyp_virt_start) &&
+                 l3_table_offset(va) <= 
+                 l3_table_offset(hyp_virt_end))
                 return 0;
 
         return 1;
-    } else 
-
-    /* Always need l1 frames */
-    if(level == L1_FRAME)
-        return 1;
+    } 
+    else 
+        /* Always need l1 frames */
+        if ( level == L1_FRAME )
+            return 1;
 
     printk("ERROR: Unknown frame level %d, hypervisor %llx,%llx\n", 
-        level, hyp_virt_start, hyp_virt_end);
+           level, hyp_virt_start, hyp_virt_end);
     return -1;
 }
 
-void build_pagetable(unsigned long *start_pfn, unsigned long *max_pfn)
+/*
+ * Build the initial pagetable.
+ */
+static void build_pagetable(unsigned long *start_pfn, unsigned long *max_pfn)
 {
     unsigned long start_address, end_address;
     unsigned long pfn_to_map, pt_pfn = *start_pfn;
     static mmu_update_t mmu_updates[L1_PAGETABLE_ENTRIES + 1];
     pgentry_t *tab = (pgentry_t *)start_info.pt_base, page;
-    unsigned long mfn = pfn_to_mfn(virt_to_pfn(start_info.pt_base));
+    unsigned long pt_mfn = pfn_to_mfn(virt_to_pfn(start_info.pt_base));
     unsigned long offset;
     int count = 0;
+    int rc;
 
-    pfn_to_map = (start_info.nr_pt_frames - NOT_L1_FRAMES) * L1_PAGETABLE_ENTRIES;
+    pfn_to_map = 
+        (start_info.nr_pt_frames - NOT_L1_FRAMES) * L1_PAGETABLE_ENTRIES;
 
-    if (*max_pfn >= virt_to_pfn(HYPERVISOR_VIRT_START))
+    if ( *max_pfn >= virt_to_pfn(HYPERVISOR_VIRT_START) )
     {
         printk("WARNING: Mini-OS trying to use Xen virtual space. "
                "Truncating memory from %dMB to ",
-               ((unsigned long)pfn_to_virt(*max_pfn) - (unsigned long)&_text)>>20);
+               ((unsigned long)pfn_to_virt(*max_pfn) -
+                (unsigned long)&_text)>>20);
         *max_pfn = virt_to_pfn(HYPERVISOR_VIRT_START - PAGE_SIZE);
         printk("%dMB\n",
-               ((unsigned long)pfn_to_virt(*max_pfn) - (unsigned long)&_text)>>20);
+               ((unsigned long)pfn_to_virt(*max_pfn) - 
+                (unsigned long)&_text)>>20);
     }
 
     start_address = (unsigned long)pfn_to_virt(pfn_to_map);
@@ -200,49 +221,53 @@
     /* We worked out the virtual memory range to map, now mapping loop */
     printk("Mapping memory range 0x%lx - 0x%lx\n", start_address, end_address);
 
-    while(start_address < end_address)
+    while ( start_address < end_address )
     {
         tab = (pgentry_t *)start_info.pt_base;
-        mfn = pfn_to_mfn(virt_to_pfn(start_info.pt_base));
+        pt_mfn = pfn_to_mfn(virt_to_pfn(start_info.pt_base));
 
 #if defined(__x86_64__)
         offset = l4_table_offset(start_address);
         /* Need new L3 pt frame */
-        if(!(start_address & L3_MASK)) 
-            if(need_pt_frame(start_address, L3_FRAME)) 
-                new_pt_frame(&pt_pfn, mfn, offset, L3_FRAME);
+        if ( !(start_address & L3_MASK) )
+            if ( need_pt_frame(start_address, L3_FRAME) ) 
+                new_pt_frame(&pt_pfn, pt_mfn, offset, L3_FRAME);
 
         page = tab[offset];
-        mfn = pte_to_mfn(page);
-        tab = to_virt(mfn_to_pfn(mfn) << PAGE_SHIFT);
+        pt_mfn = pte_to_mfn(page);
+        tab = to_virt(mfn_to_pfn(pt_mfn) << PAGE_SHIFT);
 #endif
         offset = l3_table_offset(start_address);
         /* Need new L2 pt frame */
-        if(!(start_address & L2_MASK))
-            if(need_pt_frame(start_address, L2_FRAME))
-                new_pt_frame(&pt_pfn, mfn, offset, L2_FRAME);
+        if ( !(start_address & L2_MASK) )
+            if ( need_pt_frame(start_address, L2_FRAME) )
+                new_pt_frame(&pt_pfn, pt_mfn, offset, L2_FRAME);
 
         page = tab[offset];
-        mfn = pte_to_mfn(page);
-        tab = to_virt(mfn_to_pfn(mfn) << PAGE_SHIFT);
+        pt_mfn = pte_to_mfn(page);
+        tab = to_virt(mfn_to_pfn(pt_mfn) << PAGE_SHIFT);
         offset = l2_table_offset(start_address);        
         /* Need new L1 pt frame */
-        if(!(start_address & L1_MASK))
-            if(need_pt_frame(start_address, L1_FRAME)) 
-                new_pt_frame(&pt_pfn, mfn, offset, L1_FRAME);
+        if ( !(start_address & L1_MASK) )
+            if ( need_pt_frame(start_address, L1_FRAME) )
+                new_pt_frame(&pt_pfn, pt_mfn, offset, L1_FRAME);
 
         page = tab[offset];
-        mfn = pte_to_mfn(page);
+        pt_mfn = pte_to_mfn(page);
         offset = l1_table_offset(start_address);
 
-        mmu_updates[count].ptr = ((pgentry_t)mfn << PAGE_SHIFT) + sizeof(pgentry_t) * offset;
-        mmu_updates[count].val = (pgentry_t)pfn_to_mfn(pfn_to_map++) << PAGE_SHIFT | L1_PROT;
+        mmu_updates[count].ptr =
+            ((pgentry_t)pt_mfn << PAGE_SHIFT) + sizeof(pgentry_t) * offset;
+        mmu_updates[count].val = 
+            (pgentry_t)pfn_to_mfn(pfn_to_map++) << PAGE_SHIFT | L1_PROT;
         count++;
-        if (count == L1_PAGETABLE_ENTRIES || pfn_to_map == *max_pfn)
+        if ( count == L1_PAGETABLE_ENTRIES || pfn_to_map == *max_pfn )
         {
-            if(HYPERVISOR_mmu_update(mmu_updates, count, NULL, DOMID_SELF) < 0)
+            rc = HYPERVISOR_mmu_update(mmu_updates, count, NULL, DOMID_SELF);
+            if ( rc < 0 )
             {
-                printk("PTE could not be updated\n");
+                printk("ERROR: build_pagetable(): PTE could not be updated\n");
+                printk("       mmu_update failed with rc=%d\n", rc);
                 do_exit();
             }
             count = 0;
@@ -253,20 +278,26 @@
     *start_pfn = pt_pfn;
 }
 
+/*
+ * Mark portion of the address space read only.
+ */
 extern void shared_info;
 static void set_readonly(void *text, void *etext)
 {
-    unsigned long start_address = ((unsigned long) text + PAGE_SIZE - 1) & PAGE_MASK;
+    unsigned long start_address =
+        ((unsigned long) text + PAGE_SIZE - 1) & PAGE_MASK;
     unsigned long end_address = (unsigned long) etext;
     static mmu_update_t mmu_updates[L1_PAGETABLE_ENTRIES + 1];
     pgentry_t *tab = (pgentry_t *)start_info.pt_base, page;
     unsigned long mfn = pfn_to_mfn(virt_to_pfn(start_info.pt_base));
     unsigned long offset;
     int count = 0;
+    int rc;
 
     printk("setting %p-%p readonly\n", text, etext);
 
-    while (start_address + PAGE_SIZE <= end_address) {
+    while ( start_address + PAGE_SIZE <= end_address )
+    {
         tab = (pgentry_t *)start_info.pt_base;
         mfn = pfn_to_mfn(virt_to_pfn(start_info.pt_base));
 
@@ -287,20 +318,25 @@
 
         offset = l1_table_offset(start_address);
 
-	if (start_address != (unsigned long)&shared_info) {
-	    mmu_updates[count].ptr = ((pgentry_t)mfn << PAGE_SHIFT) + sizeof(pgentry_t) * offset;
-	    mmu_updates[count].val = tab[offset] & ~_PAGE_RW;
-	    count++;
-	} else
-	    printk("skipped %p\n", start_address);
+        if ( start_address != (unsigned long)&shared_info )
+        {
+            mmu_updates[count].ptr = 
+                ((pgentry_t)mfn << PAGE_SHIFT) + sizeof(pgentry_t) * offset;
+            mmu_updates[count].val = tab[offset] & ~_PAGE_RW;
+            count++;
+        }
+        else
+            printk("skipped %p\n", start_address);
 
         start_address += PAGE_SIZE;
 
-        if (count == L1_PAGETABLE_ENTRIES || start_address + PAGE_SIZE > end_address)
+        if ( count == L1_PAGETABLE_ENTRIES || 
+             start_address + PAGE_SIZE > end_address )
         {
-            if(HYPERVISOR_mmu_update(mmu_updates, count, NULL, DOMID_SELF) < 0)
+            rc = HYPERVISOR_mmu_update(mmu_updates, count, NULL, DOMID_SELF);
+            if ( rc < 0 )
             {
-                printk("PTE could not be updated\n");
+                printk("ERROR: set_readonly(): PTE could not be updated\n");
                 do_exit();
             }
             count = 0;
@@ -308,41 +344,73 @@
     }
 
     {
-	mmuext_op_t op = {
-	    .cmd = MMUEXT_TLB_FLUSH_ALL,
-	};
-	int count;
-	HYPERVISOR_mmuext_op(&op, 1, &count, DOMID_SELF);
+        mmuext_op_t op = {
+            .cmd = MMUEXT_TLB_FLUSH_ALL,
+        };
+        int count;
+        HYPERVISOR_mmuext_op(&op, 1, &count, DOMID_SELF);
     }
 }
 
-void mem_test(unsigned long *start_add, unsigned long *end_add)
+/*
+ * A useful mem testing function. Write the address to every address in the
+ * range provided and read back the value. If verbose, print page walk to
+ * some VA
+ * 
+ * If we get MEM_TEST_MAX_ERRORS we might as well stop
+ */
+#define MEM_TEST_MAX_ERRORS 10 
+int mem_test(unsigned long *start_va, unsigned long *end_va, int verbose)
 {
     unsigned long mask = 0x10000;
     unsigned long *pointer;
-
-    for(pointer = start_add; pointer < end_add; pointer++)
+    int error_count = 0;
+ 
+    /* write values and print page walks */
+    if ( verbose && (((unsigned long)start_va) & 0xfffff) )
+    {
+        printk("MemTest Start: 0x%lx\n", start_va);
+        page_walk((unsigned long)start_va);
+    }
+    for ( pointer = start_va; pointer < end_va; pointer++ )
     {
-        if(!(((unsigned long)pointer) & 0xfffff))
+        if ( verbose && !(((unsigned long)pointer) & 0xfffff) )
         {
             printk("Writing to %lx\n", pointer);
             page_walk((unsigned long)pointer);
         }
         *pointer = (unsigned long)pointer & ~mask;
     }
-
-    for(pointer = start_add; pointer < end_add; pointer++)
+    if ( verbose && (((unsigned long)end_va) & 0xfffff) )
     {
-        if(((unsigned long)pointer & ~mask) != *pointer)
+        printk("MemTest End: %lx\n", end_va-1);
+        page_walk((unsigned long)end_va-1);
+    }
+ 
+    /* verify values */
+    for ( pointer = start_va; pointer < end_va; pointer++ )
+    {
+        if ( ((unsigned long)pointer & ~mask) != *pointer )
+        {
             printk("Read error at 0x%lx. Read: 0x%lx, should read 0x%lx\n",
-                (unsigned long)pointer, 
-                *pointer, 
-                ((unsigned long)pointer & ~mask));
+                   (unsigned long)pointer, *pointer, 
+                   ((unsigned long)pointer & ~mask));
+            error_count++;
+            if ( error_count >= MEM_TEST_MAX_ERRORS )
+            {
+                printk("mem_test: too many errors\n");
+                return -1;
+            }
+        }
     }
-
+    return 0;
 }
 
-static pgentry_t *get_pgt(unsigned long addr)
+
+/*
+ * get the PTE for virtual address va if it exists. Otherwise NULL.
+ */
+static pgentry_t *get_pgt(unsigned long va)
 {
     unsigned long mfn;
     pgentry_t *tab;
@@ -352,67 +420,78 @@
     mfn = virt_to_mfn(start_info.pt_base);
 
 #if defined(__x86_64__)
-    offset = l4_table_offset(addr);
-    if (!(tab[offset] & _PAGE_PRESENT))
+    offset = l4_table_offset(va);
+    if ( !(tab[offset] & _PAGE_PRESENT) )
         return NULL;
     mfn = pte_to_mfn(tab[offset]);
     tab = mfn_to_virt(mfn);
 #endif
-    offset = l3_table_offset(addr);
-    if (!(tab[offset] & _PAGE_PRESENT))
+    offset = l3_table_offset(va);
+    if ( !(tab[offset] & _PAGE_PRESENT) )
         return NULL;
     mfn = pte_to_mfn(tab[offset]);
     tab = mfn_to_virt(mfn);
-    offset = l2_table_offset(addr);
-    if (!(tab[offset] & _PAGE_PRESENT))
+    offset = l2_table_offset(va);
+    if ( !(tab[offset] & _PAGE_PRESENT) )
         return NULL;
     mfn = pte_to_mfn(tab[offset]);
     tab = mfn_to_virt(mfn);
-    offset = l1_table_offset(addr);
+    offset = l1_table_offset(va);
     return &tab[offset];
 }
 
-pgentry_t *need_pgt(unsigned long addr)
+
+/*
+ * return a valid PTE for a given virtual address. If PTE does not exist,
+ * allocate page-table pages.
+ */
+pgentry_t *need_pgt(unsigned long va)
 {
-    unsigned long mfn;
+    unsigned long pt_mfn;
     pgentry_t *tab;
     unsigned long pt_pfn;
     unsigned offset;
 
     tab = (pgentry_t *)start_info.pt_base;
-    mfn = virt_to_mfn(start_info.pt_base);
+    pt_mfn = virt_to_mfn(start_info.pt_base);
 
 #if defined(__x86_64__)
-    offset = l4_table_offset(addr);
-    if (!(tab[offset] & _PAGE_PRESENT)) {
+    offset = l4_table_offset(va);
+    if ( !(tab[offset] & _PAGE_PRESENT) )
+    {
         pt_pfn = virt_to_pfn(alloc_page());
-        new_pt_frame(&pt_pfn, mfn, offset, L3_FRAME);
+        new_pt_frame(&pt_pfn, pt_mfn, offset, L3_FRAME);
     }
     ASSERT(tab[offset] & _PAGE_PRESENT);
-    mfn = pte_to_mfn(tab[offset]);
-    tab = mfn_to_virt(mfn);
+    pt_mfn = pte_to_mfn(tab[offset]);
+    tab = mfn_to_virt(pt_mfn);
 #endif
-    offset = l3_table_offset(addr);
-    if (!(tab[offset] & _PAGE_PRESENT)) {
+    offset = l3_table_offset(va);
+    if ( !(tab[offset] & _PAGE_PRESENT) ) 
+    {
         pt_pfn = virt_to_pfn(alloc_page());
-        new_pt_frame(&pt_pfn, mfn, offset, L2_FRAME);
+        new_pt_frame(&pt_pfn, pt_mfn, offset, L2_FRAME);
     }
     ASSERT(tab[offset] & _PAGE_PRESENT);
-    mfn = pte_to_mfn(tab[offset]);
-    tab = mfn_to_virt(mfn);
-    offset = l2_table_offset(addr);
-    if (!(tab[offset] & _PAGE_PRESENT)) {
+    pt_mfn = pte_to_mfn(tab[offset]);
+    tab = mfn_to_virt(pt_mfn);
+    offset = l2_table_offset(va);
+    if ( !(tab[offset] & _PAGE_PRESENT) )
+    {
         pt_pfn = virt_to_pfn(alloc_page());
-	new_pt_frame(&pt_pfn, mfn, offset, L1_FRAME);
+        new_pt_frame(&pt_pfn, pt_mfn, offset, L1_FRAME);
     }
     ASSERT(tab[offset] & _PAGE_PRESENT);
-    mfn = pte_to_mfn(tab[offset]);
-    tab = mfn_to_virt(mfn);
+    pt_mfn = pte_to_mfn(tab[offset]);
+    tab = mfn_to_virt(pt_mfn);
 
-    offset = l1_table_offset(addr);
+    offset = l1_table_offset(va);
     return &tab[offset];
 }
 
+/*
+ * Reserve an area of virtual address space for mappings and Heap
+ */
 static unsigned long demand_map_area_start;
 #ifdef __x86_64__
 #define DEMAND_MAP_PAGES ((128ULL << 30) / PAGE_SIZE)
@@ -437,7 +516,8 @@
 
     demand_map_area_start = (unsigned long) pfn_to_virt(cur_pfn);
     cur_pfn += DEMAND_MAP_PAGES;
-    printk("Demand map pfns at %lx-%lx.\n", demand_map_area_start, pfn_to_virt(cur_pfn));
+    printk("Demand map pfns at %lx-%lx.\n", 
+           demand_map_area_start, pfn_to_virt(cur_pfn));
 
 #ifdef HAVE_LIBC
     cur_pfn++;
@@ -448,104 +528,346 @@
 #endif
 }
 
-#define MAP_BATCH ((STACK_SIZE / 2) / sizeof(mmu_update_t))
-void do_map_frames(unsigned long addr,
-        unsigned long *f, unsigned long n, unsigned long stride,
-	unsigned long increment, domid_t id, int may_fail, unsigned long prot)
-{
-    pgentry_t *pgt = NULL;
-    unsigned long done = 0;
-    unsigned long i;
-    int rc;
-
-    while (done < n) {
-	unsigned long todo;
-
-	if (may_fail)
-	    todo = 1;
-	else
-	    todo = n - done;
-
-	if (todo > MAP_BATCH)
-		todo = MAP_BATCH;
-
-	{
-	    mmu_update_t mmu_updates[todo];
-
-	    for (i = 0; i < todo; i++, addr += PAGE_SIZE, pgt++) {
-                if (!pgt || !(addr & L1_MASK))
-                    pgt = need_pgt(addr);
-		mmu_updates[i].ptr = virt_to_mach(pgt);
-		mmu_updates[i].val = ((pgentry_t)(f[(done + i) * stride] + (done + i) * increment) << PAGE_SHIFT) | prot;
-	    }
-
-	    rc = HYPERVISOR_mmu_update(mmu_updates, todo, NULL, id);
-	    if (rc < 0) {
-		if (may_fail)
-		    f[done * stride] |= 0xF0000000;
-		else {
-		    printk("Map %ld (%lx, ...) at %p failed: %d.\n", todo, f[done * stride] + done * increment, addr, rc);
-                    do_exit();
-		}
-	    }
-	}
-
-	done += todo;
-    }
-}
-
 unsigned long allocate_ondemand(unsigned long n, unsigned long alignment)
 {
     unsigned long x;
     unsigned long y = 0;
 
     /* Find a properly aligned run of n contiguous frames */
-    for (x = 0; x <= DEMAND_MAP_PAGES - n; x = (x + y + 1 + alignment - 1) & ~(alignment - 1)) {
+    for ( x = 0;
+          x <= DEMAND_MAP_PAGES - n; 
+          x = (x + y + 1 + alignment - 1) & ~(alignment - 1) )
+    {
         unsigned long addr = demand_map_area_start + x * PAGE_SIZE;
         pgentry_t *pgt = get_pgt(addr);
-        for (y = 0; y < n; y++, addr += PAGE_SIZE) {
-            if (!(addr & L1_MASK))
+        for ( y = 0; y < n; y++, addr += PAGE_SIZE ) 
+        {
+            if ( !(addr & L1_MASK) )
                 pgt = get_pgt(addr);
-            if (pgt) {
-                if (*pgt & _PAGE_PRESENT)
+            if ( pgt )
+            {
+                if ( *pgt & _PAGE_PRESENT )
                     break;
                 pgt++;
             }
         }
-        if (y == n)
+        if ( y == n )
             break;
     }
-    if (y != n) {
+    if ( y != n )
+    {
         printk("Failed to find %ld frames!\n", n);
         return 0;
     }
     return demand_map_area_start + x * PAGE_SIZE;
 }
 
-void *map_frames_ex(unsigned long *f, unsigned long n, unsigned long stride,
-	unsigned long increment, unsigned long alignment, domid_t id,
-	int may_fail, unsigned long prot)
+/*
+ * Map an array of MFNs contiguously into virtual address space starting at
+ * va. map f[i*stride]+i*increment for i in 0..n-1.
+ */
+#define MAP_BATCH ((STACK_SIZE / 2) / sizeof(mmu_update_t))
+void do_map_frames(unsigned long va,
+                   unsigned long *mfns, unsigned long n, 
+                   unsigned long stride, unsigned long incr, 
+                   domid_t id, int may_fail,
+                   unsigned long prot)
 {
-    unsigned long addr = allocate_ondemand(n, alignment);
+    pgentry_t *pgt = NULL;
+    unsigned long done = 0;
+    unsigned long i;
+    int rc;
+
+    if ( !mfns ) 
+    {
+        printk("do_map_frames: no mfns supplied\n");
+        return;
+    }
+    DEBUG("va=%p n=0x%lx, mfns[0]=0x%lx stride=0x%lx incr=0x%lx prot=0x%lx\n",
+          va, n, mfns[0], stride, incr, prot);
+ 
+    while ( done < n )
+    {
+        unsigned long todo;
+
+        if ( may_fail )
+            todo = 1;
+        else
+            todo = n - done;
+
+        if ( todo > MAP_BATCH )
+            todo = MAP_BATCH;
 
-    if (!addr)
+        {
+            mmu_update_t mmu_updates[todo];
+
+            for ( i = 0; i < todo; i++, va += PAGE_SIZE, pgt++) 
+            {
+                if ( !pgt || !(va & L1_MASK) )
+                    pgt = need_pgt(va);
+                
+                mmu_updates[i].ptr = virt_to_mach(pgt) | MMU_NORMAL_PT_UPDATE;
+                mmu_updates[i].val = ((pgentry_t)(mfns[(done + i) * stride] +
+                                                  (done + i) * incr)
+                                      << PAGE_SHIFT) | prot;
+            }
+
+            rc = HYPERVISOR_mmu_update(mmu_updates, todo, NULL, id);
+            if ( rc < 0 )
+            {
+                if (may_fail)
+                    mfns[done * stride] |= 0xF0000000;
+                else {
+                    printk("Map %ld (%lx, ...) at %p failed: %d.\n",
+                           todo, mfns[done * stride] + done * incr, va, rc);
+                    do_exit();
+                }
+            }
+        }
+        done += todo;
+    }
+}
+
+/*
+ * Map an array of MFNs contiguous into virtual address space. Virtual
+ * addresses are allocated from the on demand area.
+ */
+void *map_frames_ex(unsigned long *mfns, unsigned long n, 
+                    unsigned long stride, unsigned long incr,
+                    unsigned long alignment,
+                    domid_t id, int may_fail, unsigned long prot)
+{
+    unsigned long va = allocate_ondemand(n, alignment);
+
+    if ( !va )
         return NULL;
 
-    /* Found it at x.  Map it in. */
-    do_map_frames(addr, f, n, stride, increment, id, may_fail, prot);
+    do_map_frames(va, mfns, n, stride, incr, id, may_fail, prot);
+
+    return (void *)va;
+}
+
+/*
+ * Unmap nun_frames frames mapped at virtual address va.
+ */
+#define UNMAP_BATCH ((STACK_SIZE / 2) / sizeof(multicall_entry_t))
+int unmap_frames(unsigned long va, unsigned long num_frames)
+{
+    int n = UNMAP_BATCH;
+    multicall_entry_t call[n];
+    int ret;
+    int i;
+
+    ASSERT(!((unsigned long)va & ~PAGE_MASK));
+
+    DEBUG("va=%p, num=0x%lx\n", va, num_frames);
+
+    while ( num_frames ) {
+        if ( n > num_frames )
+            n = num_frames;
+
+        for ( i = 0; i < n; i++ )
+        {
+            int arg = 0;
+            /* simply update the PTE for the VA and invalidate TLB */
+            call[i].op = __HYPERVISOR_update_va_mapping;
+            call[i].args[arg++] = va;
+            call[i].args[arg++] = 0;
+#ifdef __i386__
+            call[i].args[arg++] = 0;
+#endif  
+            call[i].args[arg++] = UVMF_INVLPG;
+
+            va += PAGE_SIZE;
+        }
+
+        ret = HYPERVISOR_multicall(call, n);
+        if ( ret )
+        {
+            printk("update_va_mapping hypercall failed with rc=%d.\n", ret);
+            return -ret;
+        }
+
+        for ( i = 0; i < n; i++ )
+        {
+            if ( call[i].result ) 
+            {
+                printk("update_va_mapping failed for with rc=%d.\n", ret);
+                return -(call[i].result);
+            }
+        }
+        num_frames -= n;
+    }
+    return 0;
+}
+
+/*
+ * Allocate pages which are contiguous in machine memory.
+ * Returns a VA to where they are mapped or 0 on failure.
+ * 
+ * addr_bits indicates if the region has restrictions on where it is
+ * located. Typical values are 32 (if for example PCI devices can't access
+ * 64bit memory) or 0 for no restrictions.
+ *
+ * Allocated pages can be freed using the page allocators free_pages() 
+ * function.
+ *
+ * based on Linux function xen_create_contiguous_region()
+ */
+#define MAX_CONTIG_ORDER 9 /* 2MB */
+unsigned long alloc_contig_pages(int order, unsigned int addr_bits)
+{
+    unsigned long in_va, va;
+    unsigned long in_frames[1UL << order], out_frames, mfn;
+    multicall_entry_t call[1UL << order];
+    unsigned int i, num_pages = 1UL << order;
+    int ret, exch_success;
+
+    /* pass in num_pages 'extends' of size 1 and
+     * request 1 extend of size 'order */
+    struct xen_memory_exchange exchange = {
+        .in = {
+            .nr_extents   = num_pages,
+            .extent_order = 0,
+            .domid        = DOMID_SELF
+        },
+        .out = {
+            .nr_extents   = 1,
+            .extent_order = order,
+            .address_bits = addr_bits,
+            .domid        = DOMID_SELF
+        },
+        .nr_exchanged = 0
+    };
 
-    return (void *)addr;
+    if ( order > MAX_CONTIG_ORDER )
+    {
+        printk("alloc_contig_pages: order too large 0x%x > 0x%x\n",
+               order, MAX_CONTIG_ORDER);
+        return 0;
+    }
+
+    /* Allocate some potentially discontiguous pages */
+    in_va = alloc_pages(order);
+    if ( !in_va )
+    {
+        printk("alloc_contig_pages: could not get enough pages (order=0x%x\n",
+               order);
+        return 0;
+    }
+
+    /* set up arguments for exchange hyper call */
+    set_xen_guest_handle(exchange.in.extent_start, in_frames);
+    set_xen_guest_handle(exchange.out.extent_start, &out_frames);
+
+    /* unmap current frames, keep a list of MFNs */
+    for ( i = 0; i < num_pages; i++ )
+    {
+        int arg = 0;
+
+        va = in_va + (PAGE_SIZE * i);
+        in_frames[i] = virt_to_mfn(va);
+
+        /* update P2M mapping */
+        phys_to_machine_mapping[virt_to_pfn(va)] = INVALID_P2M_ENTRY;
+
+        /* build multi call */
+        call[i].op = __HYPERVISOR_update_va_mapping;
+        call[i].args[arg++] = va;
+        call[i].args[arg++] = 0;
+#ifdef __i386__
+        call[i].args[arg++] = 0;
+#endif  
+        call[i].args[arg++] = UVMF_INVLPG;
+    }
+
+    ret = HYPERVISOR_multicall(call, i);
+    if ( ret )
+    {
+        printk("Odd, update_va_mapping hypercall failed with rc=%d.\n", ret);
+        return 0;
+    }
+
+    /* try getting a contig range of MFNs */
+    out_frames = virt_to_pfn(in_va); /* PFNs to populate */
+    ret = HYPERVISOR_memory_op(XENMEM_exchange, &exchange);
+    if ( ret ) {
+        printk("mem exchanged order=0x%x failed with rc=%d, nr_exchanged=%d\n", 
+               order, ret, exchange.nr_exchanged);
+        /* we still need to return the allocated pages above to the pool
+         * ie. map them back into the 1:1 mapping etc. so we continue but 
+         * in the end return the pages to the page allocator and return 0. */
+        exch_success = 0;
+    }
+    else
+        exch_success = 1;
+
+    /* map frames into 1:1 and update p2m */
+    for ( i = 0; i < num_pages; i++ )
+    {
+        int arg = 0;
+        pte_t pte;
+
+        va = in_va + (PAGE_SIZE * i);
+        mfn = i < exchange.nr_exchanged ? (out_frames + i) : in_frames[i];
+        pte = __pte(mfn << PAGE_SHIFT | L1_PROT);
+
+        /* update P2M mapping */
+        phys_to_machine_mapping[virt_to_pfn(va)] = mfn;
+
+        /* build multi call */
+        call[i].op = __HYPERVISOR_update_va_mapping;
+        call[i].args[arg++] = va;
+#ifdef __x86_64__
+        call[i].args[arg++] = (pgentry_t)pte.pte;
+#else
+        call[i].args[arg++] = pte.pte_low;
+        call[i].args[arg++] = pte.pte_high;
+#endif  
+        call[i].args[arg++] = UVMF_INVLPG;
+    }
+    ret = HYPERVISOR_multicall(call, i);
+    if ( ret )
+    {
+        printk("update_va_mapping hypercall no. 2 failed with rc=%d.\n", ret);
+        return 0;
+    }
+
+    if ( !exch_success )
+    {
+        /* since the exchanged failed we just free the pages as well */
+        free_pages((void *) in_va, order);
+        return 0;
+    }
+    
+    return in_va;
 }
 
+/*
+ * Check if a given MFN refers to real memory
+ */
+static long system_ram_end_mfn;
+int mfn_is_ram(unsigned long mfn)
+{
+    /* very crude check if a given MFN is memory or not. Probably should
+     * make this a little more sophisticated ;) */
+    return (mfn <= system_ram_end_mfn) ? 1 : 0;
+}
+
+
+/*
+ * Clear some of the bootstrap memory
+ */
 static void clear_bootstrap(void)
 {
     pte_t nullpte = { };
+    int rc;
 
     /* Use first page as the CoW zero page */
     memset(&_text, 0, PAGE_SIZE);
     mfn_zero = virt_to_mfn((unsigned long) &_text);
-    if (HYPERVISOR_update_va_mapping(0, nullpte, UVMF_INVLPG))
-	printk("Unable to unmap NULL page\n");
+    if ( (rc = HYPERVISOR_update_va_mapping(0, nullpte, UVMF_INVLPG)) )
+        printk("Unable to unmap NULL page. rc=%d\n", rc);
 }
 
 void arch_init_p2m(unsigned long max_pfn)
@@ -570,19 +892,19 @@
     unsigned long pfn;
     
     l3_list = (unsigned long *)alloc_page(); 
-    for(pfn=0; pfn<max_pfn; pfn++)
+    for ( pfn=0; pfn<max_pfn; pfn++ )
     {
-        if(!(pfn % (L1_P2M_ENTRIES * L2_P2M_ENTRIES)))
+        if ( !(pfn % (L1_P2M_ENTRIES * L2_P2M_ENTRIES)) )
         {
             l2_list = (unsigned long*)alloc_page();
-            if((pfn >> L3_P2M_SHIFT) > 0)
+            if ( (pfn >> L3_P2M_SHIFT) > 0 )
             {
                 printk("Error: Too many pfns.\n");
                 do_exit();
             }
             l3_list[(pfn >> L2_P2M_SHIFT)] = virt_to_mfn(l2_list);  
         }
-        if(!(pfn % (L1_P2M_ENTRIES)))
+        if ( !(pfn % (L1_P2M_ENTRIES)) )
         {
             l1_list = (unsigned long*)alloc_page();
             l2_list[(pfn >> L1_P2M_SHIFT) & L2_P2M_MASK] = 
@@ -600,16 +922,16 @@
 {
     unsigned long start_pfn, max_pfn;
 
-    printk("  _text:        %p\n", &_text);
-    printk("  _etext:       %p\n", &_etext);
-    printk("  _erodata:     %p\n", &_erodata);
-    printk("  _edata:       %p\n", &_edata);
-    printk("  stack start:  %p\n", stack);
-    printk("  _end:         %p\n", &_end);
+    printk("      _text: %p(VA)\n", &_text);
+    printk("     _etext: %p(VA)\n", &_etext);
+    printk("   _erodata: %p(VA)\n", &_erodata);
+    printk("     _edata: %p(VA)\n", &_edata);
+    printk("stack start: %p(VA)\n", stack);
+    printk("       _end: %p(VA)\n", &_end);
 
     /* First page follows page table pages and 3 more pages (store page etc) */
     start_pfn = PFN_UP(to_phys(start_info.pt_base)) + 
-                start_info.nr_pt_frames + 3;
+        start_info.nr_pt_frames + 3;
     max_pfn = start_info.nr_pages;
 
     /* We need room for demand mapping and heap, clip available memory */
@@ -621,13 +943,17 @@
     }
 #endif
 
-    printk("  start_pfn:    %lx\n", start_pfn);
-    printk("  max_pfn:      %lx\n", max_pfn);
+    printk("  start_pfn: %lx\n", start_pfn);
+    printk("    max_pfn: %lx\n", max_pfn);
 
     build_pagetable(&start_pfn, &max_pfn);
     clear_bootstrap();
     set_readonly(&_text, &_erodata);
 
+    /* get the number of physical pages the system has. Used to check for
+     * system memory. */
+    system_ram_end_mfn = HYPERVISOR_memory_op(XENMEM_maximum_ram_page, NULL);
+
     *start_pfn_p = start_pfn;
     *max_pfn_p = max_pfn;
 }
diff -Nur ../extras/mini-os/arch/x86/sched.c /root/extras/mini-os/arch/x86/sched.c
--- ../extras/mini-os/arch/x86/sched.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/x86/sched.c	2009-06-17 22:09:09.000000000 +0800
@@ -100,7 +100,9 @@
     thread = xmalloc(struct thread);
     /* We can't use lazy allocation here since the trap handler runs on the stack */
     thread->stack = (char *)alloc_pages(STACK_SIZE_PAGE_ORDER);
-    thread->name = name;
+    //thread->name = name;
+    thread->name = xmalloc_array(char,sizeof(name));
+    strncpy(thread->name,name,sizeof(name));
     printk("Thread \"%s\": pointer: 0x%lx, stack: 0x%lx\n", name, thread, 
             thread->stack);
     
diff -Nur ../extras/mini-os/arch/x86/setup.c /root/extras/mini-os/arch/x86/setup.c
--- ../extras/mini-os/arch/x86/setup.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/arch/x86/setup.c	2009-06-04 22:55:12.000000000 +0800
@@ -63,10 +63,12 @@
 static
 shared_info_t *map_shared_info(unsigned long pa)
 {
-	if ( HYPERVISOR_update_va_mapping(
-		(unsigned long)shared_info, __pte(pa | 7), UVMF_INVLPG) )
+    int rc;
+
+	if ( (rc = HYPERVISOR_update_va_mapping(
+              (unsigned long)shared_info, __pte(pa | 7), UVMF_INVLPG)) )
 	{
-		printk("Failed to map shared_info!!\n");
+		printk("Failed to map shared_info!! rc=%d\n", rc);
 		do_exit();
 	}
 	return (shared_info_t *)shared_info;
diff -Nur ../extras/mini-os/console/xencons_ring.c /root/extras/mini-os/console/xencons_ring.c
--- ../extras/mini-os/console/xencons_ring.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/console/xencons_ring.c	2009-06-15 17:05:13.000000000 +0800
@@ -59,6 +59,9 @@
 	struct xencons_interface *intf = xencons_interface();
 	XENCONS_RING_IDX cons, prod;
 
+//	printk("invoke handle_input now!	");
+//	printk("in_cons = %d,	in_prod = %d\n",intf->in_cons,intf->in_prod);
+
 	cons = intf->in_cons;
 	prod = intf->in_prod;
 	mb();
@@ -98,6 +101,9 @@
 	XENCONS_RING_IDX cons, prod;
         unsigned filled = 0;
 
+//	printk("invoke xencons_ring_recv now!	");
+//	printk("in_cons = %d,	in_prod = %d\n",intf->in_cons,intf->in_prod);
+
 	cons = intf->in_cons;
 	prod = intf->in_prod;
 	mb();
diff -Nur ../extras/mini-os/domain_config /root/extras/mini-os/domain_config
--- ../extras/mini-os/domain_config	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/domain_config	2009-06-06 10:44:02.000000000 +0800
@@ -8,7 +8,7 @@
 
 #----------------------------------------------------------------------------
 # Kernel image file.
-kernel = "mini-os.gz"
+kernel = "/root/xen-3.4-testing.hg/extras/mini-os/mini-os.gz"
 
 # Initial memory allocation (in megabytes) for the new domain.
 memory = 32
@@ -16,4 +16,6 @@
 # A name for your domain. All domains must have different names.
 name = "Mini-OS"
 
+privilege = "privileged"
+
 on_crash = 'destroy'
diff -Nur ../extras/mini-os/events.c /root/extras/mini-os/events.c
--- ../extras/mini-os/events.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/events.c	2009-06-04 22:55:12.000000000 +0800
@@ -42,19 +42,23 @@
     int cpu = 0;
     shared_info_t *s = HYPERVISOR_shared_info;
     vcpu_info_t   *vcpu_info = &s->vcpu_info[cpu];
+    int rc;
 
-    for (i = 0; i < NR_EVS; i++)
+    for ( i = 0; i < NR_EVS; i++ )
     {
-        if (i == start_info.console.domU.evtchn ||
-            i == start_info.store_evtchn)
+        if ( i == start_info.console.domU.evtchn ||
+             i == start_info.store_evtchn)
             continue;
-        if (test_and_clear_bit(i, bound_ports))
+
+        if ( test_and_clear_bit(i, bound_ports) )
         {
             struct evtchn_close close;
             printk("port %d still bound!\n", i);
             mask_evtchn(i);
             close.port = i;
-            HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
+            rc = HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
+            if ( rc )
+                printk("WARN: close_port %s failed rc=%d. ignored\n", i, rc);
             clear_evtchn(i);
         }
     }
@@ -71,8 +75,9 @@
 
     clear_evtchn(port);
 
-    if (port >= NR_EVS) {
-        printk("Port number too large: %d\n", port);
+    if ( port >= NR_EVS )
+    {
+        printk("WARN: do_event(): Port number too large: %d\n", port);
         return 1;
     }
 
@@ -89,9 +94,9 @@
 evtchn_port_t bind_evtchn(evtchn_port_t port, evtchn_handler_t handler,
 						  void *data)
 {
- 	if(ev_actions[port].handler != default_handler)
+ 	if ( ev_actions[port].handler != default_handler )
         printk("WARN: Handler for port %d already registered, replacing\n",
-				port);
+               port);
 
 	ev_actions[port].data = data;
 	wmb();
@@ -104,8 +109,9 @@
 void unbind_evtchn(evtchn_port_t port )
 {
 	struct evtchn_close close;
+    int rc;
 
-	if (ev_actions[port].handler == default_handler)
+	if ( ev_actions[port].handler == default_handler )
 		printk("WARN: No handler for port %d when unbinding\n", port);
 	mask_evtchn(port);
 	clear_evtchn(port);
@@ -116,37 +122,43 @@
 	clear_bit(port, bound_ports);
 
 	close.port = port;
-	HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
+	rc = HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
+    if ( rc )
+        printk("WARN: close_port %s failed rc=%d. ignored\n", port, rc);
+        
 }
 
 evtchn_port_t bind_virq(uint32_t virq, evtchn_handler_t handler, void *data)
 {
 	evtchn_bind_virq_t op;
+    int rc;
 
 	/* Try to bind the virq to a port */
 	op.virq = virq;
 	op.vcpu = smp_processor_id();
 
-	if ( HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq, &op) != 0 )
+	if ( (rc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq, &op)) != 0 )
 	{
-		printk("Failed to bind virtual IRQ %d\n", virq);
+		printk("Failed to bind virtual IRQ %d with rc=%d\n", virq, rc);
 		return -1;
     }
     bind_evtchn(op.port, handler, data);
 	return op.port;
 }
 
-evtchn_port_t bind_pirq(uint32_t pirq, int will_share, evtchn_handler_t handler, void *data)
+evtchn_port_t bind_pirq(uint32_t pirq, int will_share,
+                        evtchn_handler_t handler, void *data)
 {
 	evtchn_bind_pirq_t op;
+    int rc;
 
 	/* Try to bind the pirq to a port */
 	op.pirq = pirq;
 	op.flags = will_share ? BIND_PIRQ__WILL_SHARE : 0;
 
-	if ( HYPERVISOR_event_channel_op(EVTCHNOP_bind_pirq, &op) != 0 )
+	if ( (rc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_pirq, &op)) != 0 )
 	{
-		printk("Failed to bind physical IRQ %d\n", pirq);
+		printk("Failed to bind physical IRQ %d with rc=%d\n", pirq, rc);
 		return -1;
 	}
 	bind_evtchn(op.port, handler, data);
@@ -173,7 +185,8 @@
     asm volatile("movl %0,%%fs ; movl %0,%%gs" :: "r" (0));
     wrmsrl(0xc0000101, &cpu0_pda); /* 0xc0000101 is MSR_GS_BASE */
     cpu0_pda.irqcount = -1;
-    cpu0_pda.irqstackptr = (void*) (((unsigned long)irqstack + 2 * STACK_SIZE) & ~(STACK_SIZE - 1));
+    cpu0_pda.irqstackptr = (void*) (((unsigned long)irqstack + 2 * STACK_SIZE)
+                                    & ~(STACK_SIZE - 1));
 #endif
     /* initialize event handler */
     for ( i = 0; i < NR_EVS; i++ )
@@ -207,15 +220,19 @@
 int evtchn_alloc_unbound(domid_t pal, evtchn_handler_t handler,
 						 void *data, evtchn_port_t *port)
 {
-    int err;
+    int rc;
+
     evtchn_alloc_unbound_t op;
     op.dom = DOMID_SELF;
     op.remote_dom = pal;
-    err = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound, &op);
-    if (err)
-		return err;
+    rc = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound, &op);
+    if ( rc )
+    {
+        printk("ERROR: alloc_unbound failed with rc=%d", rc);
+		return rc;
+    }
     *port = bind_evtchn(op.port, handler, data);
-    return err;
+    return rc;
 }
 
 /* Connect to a port so as to allow the exchange of notifications with
@@ -225,15 +242,28 @@
 			    evtchn_handler_t handler, void *data,
 			    evtchn_port_t *local_port)
 {
-    int err;
+    int rc;
     evtchn_port_t port;
     evtchn_bind_interdomain_t op;
     op.remote_dom = pal;
     op.remote_port = remote_port;
-    err = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain, &op);
-    if (err)
-		return err;
+    rc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain, &op);
+    if ( rc )
+    {
+        printk("ERROR: bind_interdomain failed with rc=%d", rc);
+		return rc;
+    }
     port = op.local_port;
     *local_port = bind_evtchn(port, handler, data);
-    return err;
+    return rc;
 }
+
+/*
+ * Local variables:
+ * mode: C
+ * c-set-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -Nur ../extras/mini-os/fs-front.c /root/extras/mini-os/fs-front.c
--- ../extras/mini-os/fs-front.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/fs-front.c	2009-06-04 22:55:12.000000000 +0800
@@ -869,18 +869,6 @@
     in_irq = 0;
 }
 
-/* Small utility function to figure out our domain id */
-static domid_t get_self_id(void)
-{
-    char *dom_id;
-    domid_t ret; 
-
-    BUG_ON(xenbus_read(XBT_NIL, "domid", &dom_id));
-    sscanf(dom_id, "%d", &ret);
-
-    return ret;
-}
-
 static void alloc_request_table(struct fs_import *import)
 {
     struct fs_request *requests;
@@ -1066,7 +1054,7 @@
     unmask_evtchn(import->local_port);
 
     
-    self_id = get_self_id(); 
+    self_id = xenbus_get_self_id(); 
     /* Write the frontend info to a node in our Xenbus */
     sprintf(nodename, "/local/domain/%d/device/vfs/%d", 
                         self_id, import->import_id);
diff -Nur ../extras/mini-os/include/blkfront.h /root/extras/mini-os/include/blkfront.h
--- ../extras/mini-os/include/blkfront.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/blkfront.h	2009-06-04 22:55:12.000000000 +0800
@@ -8,6 +8,8 @@
     uint8_t *aio_buf;
     size_t aio_nbytes;
     off_t aio_offset;
+    size_t total_bytes;
+    uint8_t is_write;
     void *data;
 
     grant_ref_t gref[BLKIF_MAX_SEGMENTS_PER_REQUEST];
diff -Nur ../extras/mini-os/include/ia64/atomic.h /root/extras/mini-os/include/ia64/atomic.h
--- ../extras/mini-os/include/ia64/atomic.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/ia64/atomic.h	2009-06-04 22:55:12.000000000 +0800
@@ -427,11 +427,10 @@
 static inline void
 set_bit(int num, volatile void *addr)
 {
-	uint32_t bit, b, old, new;
+	uint32_t bit, old, new;
 	volatile uint32_t *p;
 	p = (volatile uint32_t *) addr + (num >> 5);
-	b = 1 << (num & 31);
-	bit = SWAP(b);
+	bit = 1 << (num & 31);
 	do
 	{
 		old = *p;
@@ -442,11 +441,10 @@
 static __inline__ void
 clear_bit(int num, volatile void *addr)
 {
-	uint32_t mask, m,  old, new;
+	uint32_t mask, old, new;
 	volatile uint32_t *p;
 	p = (volatile uint32_t *) addr + (num >> 5);
-	m = ~(1 << (num & 31));
-	mask = SWAP(m);
+	mask = ~(1 << (num & 31));
 	do {
 		old = *p;
 		new = old & mask;
@@ -456,7 +454,7 @@
 static __inline__ int
 test_bit(int num, const volatile void *addr)
 {
-	uint32_t val = SWAP(1);
+	uint32_t val = 1;
         return val & (((const volatile uint32_t *) addr)[num >> 5] >> (num & 31));
 }
 
@@ -468,12 +466,11 @@
 static inline int
 test_and_set_bit (int num, volatile void *addr)
 {
-        uint32_t bit, b, old, new;
+        uint32_t bit, old, new;
         volatile uint32_t *m;
 
         m = (volatile uint32_t *) addr + (num >> 5);
-        b = 1 << (num & 31);
-        bit = SWAP(b);
+        bit = 1 << (num & 31);
         do {
                 old = *m;
                 new = old | bit;
@@ -489,12 +486,11 @@
 static
 inline int test_and_clear_bit(int num, volatile unsigned long * addr)
 {
-        uint32_t bit, b, old, new;
+        uint32_t bit, old, new;
         volatile uint32_t* a;
 
         a = (volatile uint32_t *) addr + (num >> 5);
-        b = ~(1 << (num & 31));
-        bit = SWAP(b);
+        bit = ~(1 << (num & 31));
         do {
                 old = *a;
                 new = old & bit;
diff -Nur ../extras/mini-os/include/ia64/endian.h /root/extras/mini-os/include/ia64/endian.h
--- ../extras/mini-os/include/ia64/endian.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/ia64/endian.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,75 +0,0 @@
-/*
- * Done by Dietmar Hahn <dietmar.hahn@fujitsu-siemens.com>
- * Parts are taken from FreeBSD.
- *
- ****************************************************************************
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to
- * deal in the Software without restriction, including without limitation the
- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
- * sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
- * DEALINGS IN THE SOFTWARE.
- */
-
-
-#if !defined(_ENDIAN_H_)
-#define _ENDIAN_H_
-
-#include <mini-os/types.h>
-
-
-#if !defined(__ASSEMBLY__)
-
-#if defined(BIG_ENDIAN)
-
-static __inline uint64_t
-__bswap64(uint64_t __x)
-{
-	uint64_t __r;
-	asm __volatile("mux1 %0=%1,@rev" : "=r" (__r) : "r"(__x));
-	return __r;
-}
-
-static __inline uint32_t
-__bswap32(uint32_t __x)
-{
-	return (__bswap64(__x) >> 32);
-}
-
-static __inline uint16_t
-__bswap16(uint16_t __x)
-{
-	return (__bswap64(__x) >> 48);
-}
-
-#define doswap(x,sz)  ( \
-	((sz)==1)? (uint8_t)(x): \
-	((sz)==2)? __bswap16(x): \
-	((sz)==4)? __bswap32(x): \
-	((sz)==8)? __bswap64(x): \
-	~0l )
-
-#define SWAP(x)	doswap((x), sizeof((x)))
-
-
-#else /* defined(BIG_ENDIAN) */
-
-#define SWAP(x) (x)
-
-#endif /* defined(BIG_ENDIAN) */
-
-#endif /* !defined(__ASSEMBLY__) */
-
-
-#endif /* !defined(_ENDIAN_H_) */
diff -Nur ../extras/mini-os/include/ia64/hypercall-ia64.h /root/extras/mini-os/include/ia64/hypercall-ia64.h
--- ../extras/mini-os/include/ia64/hypercall-ia64.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/ia64/hypercall-ia64.h	2009-06-04 22:55:12.000000000 +0800
@@ -34,8 +34,6 @@
 #ifndef __HYPERCALL_H__
 #define __HYPERCALL_H__
 
-#include <mini-os/lib.h>	/* memcpy() */
-#include <mini-os/errno.h>	/* ENOSYS() */
 #include <xen/event_channel.h>
 #include <xen/sched.h>
 #include <xen/version.h>
@@ -114,123 +112,24 @@
 })
 
 
-extern unsigned long xencomm_vaddr_to_paddr(unsigned long vaddr);
-struct xencomm_handle;
+int HYPERVISOR_event_channel_op(int cmd, void *arg);
 
-/* Inline version.  To be used only on linear space (kernel space).  */
-static inline struct xencomm_handle *
-xencomm_create_inline(void *buffer)
-{
-	unsigned long paddr;
-
-	paddr = xencomm_vaddr_to_paddr((unsigned long)buffer);
-	return (struct xencomm_handle *)(paddr | XENCOMM_INLINE_FLAG);
-}
-
-static inline int
-xencomm_arch_event_channel_op(int cmd, void *arg)
-{
-	int rc;
-	struct xencomm_handle *newArg;
-
-	newArg = xencomm_create_inline(arg);
-	rc = _hypercall2(int, event_channel_op, cmd, newArg);
-	if (unlikely(rc == -ENOSYS)) {
-		struct evtchn_op op;
-
-		op.cmd = SWAP(cmd);
-		memcpy(&op.u, arg, sizeof(op.u));
-		rc = _hypercall1(int, event_channel_op_compat, &op);
-	}
-	return rc;
-}
-#define HYPERVISOR_event_channel_op xencomm_arch_event_channel_op
-
-static inline int
-xencomm_arch_xen_version(int cmd, struct xencomm_handle *arg)
-{
-	return _hypercall2(int, xen_version, cmd, arg);
-}
-
-static inline int
-xencomm_arch_xen_feature(int cmd, struct xencomm_handle *arg)
-{
-	struct xencomm_handle *newArg;
-
-	newArg = xencomm_create_inline(arg);
-	return _hypercall2(int, xen_version, cmd, newArg);
-}
-
-static inline int
-HYPERVISOR_xen_version(int cmd, void *arg)
-{
-	switch(cmd) {
-		case XENVER_version:
-			return xencomm_arch_xen_version(cmd, 0);
-		case XENVER_get_features:
-			return xencomm_arch_xen_feature(cmd, arg);
-		default:
-			return -1;
-	}
-}
-
-static inline int
-xencomm_arch_console_io(int cmd, int count, char *str)
-{
-	struct xencomm_handle *newStr;
-
-	newStr = xencomm_create_inline(str);
-	return _hypercall3(int, console_io, cmd, count, newStr);
-}
-
-
-#define HYPERVISOR_console_io xencomm_arch_console_io
-
-static inline int
-HYPERVISOR_sched_op_compat(int cmd, unsigned long arg)
-{
-	return _hypercall2(int, sched_op_compat, cmd, arg);
-}
-
-static inline int
-xencomm_arch_sched_op(int cmd, void *arg)
-{
-	struct xencomm_handle *newArg;
-
-	newArg = xencomm_create_inline(arg);
-	return _hypercall2(int, sched_op, cmd, newArg);
-}
-
-#define HYPERVISOR_sched_op xencomm_arch_sched_op
-
-static inline int
-xencomm_arch_callback_op(int cmd, void *arg)
-{
-	struct xencomm_handle *newArg;
-
-	newArg = xencomm_create_inline(arg);
-	return _hypercall2(int, callback_op, cmd, newArg);
-}
-#define HYPERVISOR_callback_op xencomm_arch_callback_op
-
-static inline int
-xencomm_arch_hypercall_grant_table_op(unsigned int cmd,
-                                      struct xencomm_handle *uop,
-                                      unsigned int count)
-{
-	return _hypercall3(int, grant_table_op, cmd, uop, count);
-}
+int HYPERVISOR_xen_version(int cmd, void *arg);
+
+int HYPERVISOR_console_io(int cmd, int count, char *str);
+
+int HYPERVISOR_sched_op_compat(int cmd, unsigned long arg);
+
+int HYPERVISOR_sched_op(int cmd, void *arg);
+
+int HYPERVISOR_callback_op(int cmd, void *arg);
 
 int HYPERVISOR_grant_table_op(unsigned int cmd, void *uop, unsigned int count);
 
-static inline int
-HYPERVISOR_opt_feature(void *arg)
-{
-	struct xencomm_handle *new_arg;
+int HYPERVISOR_opt_feature(void *arg);
 
-	new_arg = xencomm_create_inline(arg);
+int HYPERVISOR_suspend(unsigned long srec);
 
-	return _hypercall1(int, opt_feature, new_arg);
-}
+int HYPERVISOR_shutdown(unsigned int reason);
 
 #endif /* __HYPERCALL_H__ */
diff -Nur ../extras/mini-os/include/ia64/ia64_cpu.h /root/extras/mini-os/include/ia64/ia64_cpu.h
--- ../extras/mini-os/include/ia64/ia64_cpu.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/ia64/ia64_cpu.h	2009-06-04 22:55:12.000000000 +0800
@@ -134,23 +134,16 @@
 #define IA64_PSR_IA		0x0000200000000000
 
 
-/* Endianess of mini-os. */
-#if defined(BIG_ENDIAN)
-#define MOS_IA64_PSR_BE	IA64_PSR_BE
-#else
-#define MOS_IA64_PSR_BE	0
-#endif
-
 #define STARTUP_PSR (IA64_PSR_IT | IA64_PSR_PK | \
-            	     IA64_PSR_DT | IA64_PSR_RT | MOS_IA64_PSR_BE | \
+            	     IA64_PSR_DT | IA64_PSR_RT | \
 		     IA64_PSR_BN | IA64_PSR_CPL_KERN | IA64_PSR_AC)
 
 #define MOS_SYS_PSR (IA64_PSR_IC | IA64_PSR_I | IA64_PSR_IT | \
-            	     IA64_PSR_DT | IA64_PSR_RT | MOS_IA64_PSR_BE | \
+            	     IA64_PSR_DT | IA64_PSR_RT | \
 		     IA64_PSR_BN | IA64_PSR_CPL_KERN | IA64_PSR_AC)
 
 #define MOS_USR_PSR (IA64_PSR_IC | IA64_PSR_I | IA64_PSR_IT | \
-            	     IA64_PSR_DT | IA64_PSR_RT | MOS_IA64_PSR_BE | \
+            	     IA64_PSR_DT | IA64_PSR_RT | \
 		     IA64_PSR_BN | IA64_PSR_CPL_USER | IA64_PSR_AC)
 
 /*
@@ -193,14 +186,7 @@
 #define IA64_DCR_MBZ1_V		0xffffffffffffULL
 
 
-	/* Endianess of DCR register. */
-#if defined(BIG_ENDIAN)
-#define MOS_IA64_DCR_BE	(1 << IA64_DCR_BE)
-#else
-#define MOS_IA64_DCR_BE	(0 << IA64_DCR_BE)
-#endif
-
-#define IA64_DCR_DEFAULT (MOS_IA64_DCR_BE)
+#define IA64_DCR_DEFAULT (IA64_DCR_BE)
 
 /*
  * Vector numbers for various ia64 interrupts.
@@ -262,18 +248,8 @@
 #define IA64_RSC_MODE_LI (0x2) 		/* Load intensive */
 #define IA64_RSC_MODE_EA (0x3) 		/* Eager */
 
-/* RSE endian mode. */
-#if defined(BIG_ENDIAN)
-#define MOS_IA64_RSC_BE	1		/* Big endian rse. */
-#else
-#define MOS_IA64_RSC_BE	0		/* Little endian rse. */
-#endif
-
-#define IA64_RSE_EAGER ((IA64_RSC_MODE_EA<<IA64_RSC_MODE) |	\
-			   (MOS_IA64_RSC_BE << IA64_RSC_BE)	)
-
-#define IA64_RSE_LAZY ((IA64_RSC_MODE_LY<<IA64_RSC_MODE) |	\
-			   (MOS_IA64_RSC_BE << IA64_RSC_BE)	)
+#define IA64_RSE_EAGER (IA64_RSC_MODE_EA<<IA64_RSC_MODE)
+#define IA64_RSE_LAZY (IA64_RSC_MODE_LY<<IA64_RSC_MODE)
 
 
 
@@ -719,19 +695,6 @@
  */
 typedef struct
 {
-#if defined(BIG_ENDIAN)
-	uint64_t pte_ig	:11;	/* bits 53..63 */
-	uint64_t pte_ed	:1;	/* bits 52..52 */
-	uint64_t pte_rv2:2;	/* bits 50..51 */
-	uint64_t pte_ppn:38;	/* bits 12..49 */
-	uint64_t pte_ar	:3;	/* bits 9..11 */
-	uint64_t pte_pl	:2;	/* bits 7..8 */
-	uint64_t pte_d	:1;	/* bits 6..6 */
-	uint64_t pte_a	:1;	/* bits 5..5 */
-	uint64_t pte_ma	:3;	/* bits 2..4 */
-	uint64_t pte_rv1:1;	/* bits 1..1 */
-	uint64_t pte_p	:1;	/* bits 0..0 */
-#else
 	uint64_t pte_p	:1;	/* bits 0..0 */
 	uint64_t pte_rv1:1;	/* bits 1..1 */
 	uint64_t pte_ma	:3;	/* bits 2..4 */
@@ -743,7 +706,6 @@
 	uint64_t pte_rv2:2;	/* bits 50..51 */
 	uint64_t pte_ed	:1;	/* bits 52..52 */
 	uint64_t pte_ig	:11;	/* bits 53..63 */
-#endif
 } ia64_pte_t;
 
 
diff -Nur ../extras/mini-os/include/ia64/os.h /root/extras/mini-os/include/ia64/os.h
--- ../extras/mini-os/include/ia64/os.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/ia64/os.h	2009-06-04 22:55:12.000000000 +0800
@@ -28,7 +28,6 @@
 #if !defined(__ASSEMBLY__)
 
 #include <mini-os/types.h>
-#include "endian.h"
 #include "ia64_cpu.h"
 #include "atomic.h"
 #include "efi.h"
@@ -192,21 +191,6 @@
 
 extern shared_info_t *HYPERVISOR_shared_info;
 
-static inline int
-HYPERVISOR_shutdown(unsigned int reason)
-{
-	struct sched_shutdown sched_shutdown = {
-		.reason = reason
-	};
-
-	int rc = HYPERVISOR_sched_op(SCHEDOP_shutdown, &sched_shutdown);
-
-	if (rc == -ENOSYS)
-		rc = HYPERVISOR_sched_op_compat(SCHEDOP_shutdown, reason);
-
-	return rc;
-}
-
 
 /*
  * This code is from the originally os.h and should be put in a
@@ -225,7 +209,7 @@
 do {									\
 	vcpu_info_t *_vcpu;						\
 	_vcpu = &HYPERVISOR_shared_info->vcpu_info[smp_processor_id()];	\
-	_vcpu->evtchn_upcall_mask = SWAP(1);				\
+	_vcpu->evtchn_upcall_mask = 1;					\
 	barrier();							\
 } while (0)
 
@@ -236,7 +220,7 @@
 	_vcpu = &HYPERVISOR_shared_info->vcpu_info[smp_processor_id()];	\
 	_vcpu->evtchn_upcall_mask = 0;					\
 	barrier(); /* unmask then check (avoid races) */		\
-	if (unlikely(SWAP(_vcpu->evtchn_upcall_pending)))		\
+	if (unlikely(_vcpu->evtchn_upcall_pending))			\
 		force_evtchn_callback();				\
 } while (0)
 
@@ -244,7 +228,7 @@
 do {									\
 	vcpu_info_t *_vcpu;						\
 	_vcpu = &HYPERVISOR_shared_info->vcpu_info[smp_processor_id()];	\
-	(x) = SWAP(_vcpu->evtchn_upcall_mask);				\
+	(x) = _vcpu->evtchn_upcall_mask;				\
 } while (0)
 
 #define __restore_flags(x)						\
@@ -254,7 +238,7 @@
 	_vcpu = &HYPERVISOR_shared_info->vcpu_info[smp_processor_id()];	\
 	if ((_vcpu->evtchn_upcall_mask = (x)) == 0) {			\
 		barrier(); /* unmask then check (avoid races) */	\
-		if ( unlikely(SWAP(_vcpu->evtchn_upcall_pending)) )	\
+		if ( unlikely(_vcpu->evtchn_upcall_pending) )		\
 			force_evtchn_callback();			\
 	}\
 } while (0)
@@ -265,8 +249,8 @@
 do {									\
 	vcpu_info_t *_vcpu;						\
 	_vcpu = &HYPERVISOR_shared_info->vcpu_info[smp_processor_id()];	\
-	(x) = SWAP(_vcpu->evtchn_upcall_mask);				\
-	_vcpu->evtchn_upcall_mask = SWAP(1);				\
+	(x) = _vcpu->evtchn_upcall_mask;				\
+	_vcpu->evtchn_upcall_mask = 1;					\
 	barrier();							\
 } while (0)
 
@@ -277,7 +261,7 @@
 #define local_irq_enable()	__sti()
 
 #define irqs_disabled()			\
-	SWAP(HYPERVISOR_shared_info->vcpu_info[smp_processor_id()].evtchn_upcall_mask)
+	(HYPERVISOR_shared_info->vcpu_info[smp_processor_id()].evtchn_upcall_mask)
 
 /* This is a barrier for the compiler only, NOT the processor! */
 #define barrier() __asm__ __volatile__("": : :"memory")
diff -Nur ../extras/mini-os/include/ioremap.h /root/extras/mini-os/include/ioremap.h
--- ../extras/mini-os/include/ioremap.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/ioremap.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,33 @@
+/**
+ * Copyright (C) 2009 Netronome Systems, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+
+#ifndef _IOREMAP_H_
+#define _IOREMAP_H_
+
+void *ioremap(unsigned long phys_addr, unsigned long size);
+void *ioremap_nocache(unsigned long phys_addr, unsigned long size);
+void iounmap(void *virt_addr, unsigned long size);
+
+#endif /* _IOREMAP_H_ */
+
+/* -*-  Mode:C; c-basic-offset:4; tab-width:4 indent-tabs-mode:nil -*- */
diff -Nur ../extras/mini-os/include/lib.h /root/extras/mini-os/include/lib.h
--- ../extras/mini-os/include/lib.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/lib.h	2009-06-15 11:09:38.000000000 +0800
@@ -196,6 +196,7 @@
 void close_all_files(void);
 extern struct thread *main_thread;
 void sparse(unsigned long data, size_t size);
+int read(int fd, void *buf, size_t nbytes);
 #endif
 
 #endif /* _LIB_H_ */
diff -Nur ../extras/mini-os/include/mm.h /root/extras/mini-os/include/mm.h
--- ../extras/mini-os/include/mm.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/mm.h	2009-06-04 22:55:12.000000000 +0800
@@ -71,6 +71,8 @@
 void do_map_frames(unsigned long addr,
         unsigned long *f, unsigned long n, unsigned long stride,
 	unsigned long increment, domid_t id, int may_fail, unsigned long prot);
+int unmap_frames(unsigned long va, unsigned long num_frames);
+unsigned long alloc_contig_pages(int order, unsigned int addr_bits);
 #ifdef HAVE_LIBC
 extern unsigned long heap, brk, heap_mapped, heap_end;
 #endif
diff -Nur ../extras/mini-os/include/posix/arpa/inet.h /root/extras/mini-os/include/posix/arpa/inet.h
--- ../extras/mini-os/include/posix/arpa/inet.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/posix/arpa/inet.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,7 @@
+#ifndef _POSIX_ARPA_INET_H_
+#define	_POSIX_ARPA_INET_H_
+
+#include <lwip/inet.h>
+
+#endif /* _POSIX_ARPA_INET_H_ */
+
diff -Nur ../extras/mini-os/include/posix/dirent.h /root/extras/mini-os/include/posix/dirent.h
--- ../extras/mini-os/include/posix/dirent.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/posix/dirent.h	2009-06-04 22:55:12.000000000 +0800
@@ -1,7 +1,7 @@
 #ifndef _POSIX_DIRENT_H
 #define _POSIX_DIRENT_H
 
-#include <sys/types.h>
+#include <stdint.h>
 
 struct dirent {
         char *d_name;
diff -Nur ../extras/mini-os/include/posix/err.h /root/extras/mini-os/include/posix/err.h
--- ../extras/mini-os/include/posix/err.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/posix/err.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,15 @@
+#ifndef _POSIX_ERR_H
+#define _POSIX_ERR_H
+
+#include <stdarg.h>
+
+void err(int eval, const char *fmt, ...);
+void errx(int eval, const char *fmt, ...);
+void warn(const char *fmt, ...);
+void warnx(const char *fmt, ...);
+void verr(int eval, const char *fmt, va_list args);
+void verrx(int eval, const char *fmt, va_list args);
+void vwarn(const char *fmt, va_list args);
+void vwarnx(const char *fmt, va_list args);
+
+#endif /* _POSIX_ERR_H */
diff -Nur ../extras/mini-os/include/posix/net/if.h /root/extras/mini-os/include/posix/net/if.h
--- ../extras/mini-os/include/posix/net/if.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/posix/net/if.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,85 @@
+/*
+ * This code is mostly taken from NetBSD net/if.h 
+ * Changes: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
+ *
+ ******************************************************************************
+ *
+ * Copyright (c) 1999, 2000, 2001 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by William Studenmund and Jason R. Thorpe.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *      The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef _NET_IF_H_
+#define _NET_IF_H_
+
+/*
+ * Length of interface external name, including terminating '\0'.
+ * Note: this is the same size as a generic device's external name.
+ */
+#define IF_NAMESIZE 16
+
+struct if_nameindex {
+        unsigned int    if_index;       /* 1, 2, ... */
+        char            *if_name;       /* null terminated name: "le0", ... */
+};
+
+unsigned int if_nametoindex(const char *);
+char *  if_indextoname(unsigned int, char *);
+struct  if_nameindex * if_nameindex(void);
+void    if_freenameindex(struct if_nameindex *);
+
+#endif /* !_NET_IF_H_ */
+
diff -Nur ../extras/mini-os/include/posix/pthread.h /root/extras/mini-os/include/posix/pthread.h
--- ../extras/mini-os/include/posix/pthread.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/posix/pthread.h	2009-06-04 22:55:12.000000000 +0800
@@ -31,8 +31,15 @@
 
 
 
+typedef struct {} pthread_mutexattr_t;
+static inline int pthread_mutexattr_init(pthread_mutexattr_t *mattr) { return 0; }
+#define PTHREAD_MUTEX_NORMAL 0
+#define PTHREAD_MUTEX_RECURSIVE 1
+static inline int pthread_mutexattr_settype(pthread_mutexattr_t *mattr, int kind) { return 0; }
+static inline int pthread_mutexattr_destroy(pthread_mutexattr_t *mattr) { return 0; }
 typedef struct {} pthread_mutex_t;
 #define PTHREAD_MUTEX_INITIALIZER {}
+static inline int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *mattr) { return 0; }
 static inline int pthread_mutex_lock(pthread_mutex_t *mutex) { return 0; }
 static inline int pthread_mutex_unlock(pthread_mutex_t *mutex) { return 0; }
 
diff -Nur ../extras/mini-os/include/posix/signal.h /root/extras/mini-os/include/posix/signal.h
--- ../extras/mini-os/include/posix/signal.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/posix/signal.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,10 @@
+#ifndef _POSIX_SIGNAL_H
+#define _POSIX_SIGNAL_H
+
+#include_next <signal.h>
+
+int sigaction(int signum, const struct sigaction * __restrict,
+              struct sigaction * __restrict);
+
+#endif
+
diff -Nur ../extras/mini-os/include/posix/sys/poll.h /root/extras/mini-os/include/posix/sys/poll.h
--- ../extras/mini-os/include/posix/sys/poll.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/posix/sys/poll.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,79 @@
+/*
+ * This code is mostly taken from FreeBSD sys/sys/poll.h 
+ * Changes: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
+ *
+ ****************************************************************************
+ * Copyright (c) 1997 Peter Wemm <peter@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _POSIX_SYS_POLL_H_
+#define	_POSIX_SYS_POLL_H_
+
+/*
+ * This file is intended to be compatible with the traditional poll.h.
+ */
+
+typedef	unsigned int	nfds_t;
+
+/*
+ * This structure is passed as an array to poll(2).
+ */
+struct pollfd {
+	int	fd;		/* which file descriptor to poll */
+	short	events;		/* events we are interested in */
+	short	revents;	/* events found on return */
+};
+
+/*
+ * Requestable events.  If poll(2) finds any of these set, they are
+ * copied to revents on return.
+ * XXX Note that FreeBSD doesn't make much distinction between POLLPRI
+ * and POLLRDBAND since none of the file types have distinct priority
+ * bands - and only some have an urgent "mode".
+ * XXX Note POLLIN isn't really supported in true SVSV terms.  Under SYSV
+ * POLLIN includes all of normal, band and urgent data.  Most poll handlers
+ * on FreeBSD only treat it as "normal" data.
+ */
+#define	POLLIN		0x0001		/* any readable data available */
+#define	POLLPRI		0x0002		/* OOB/Urgent readable data */
+#define	POLLOUT		0x0004		/* file descriptor is writeable */
+#define	POLLRDNORM	0x0040		/* non-OOB/URG data available */
+#define	POLLWRNORM	POLLOUT		/* no write type differentiation */
+#define	POLLRDBAND	0x0080		/* OOB/Urgent readable data */
+#define	POLLWRBAND	0x0100		/* OOB/Urgent data can be written */
+
+/*
+ * These events are set if they occur regardless of whether they were
+ * requested.
+ */
+#define	POLLERR		0x0008		/* some poll error occurred */
+#define	POLLHUP		0x0010		/* file descriptor was "hung up" */
+#define	POLLNVAL	0x0020		/* requested events "invalid" */
+
+int	poll(struct pollfd _pfd[], nfds_t _nfds, int _timeout);
+
+#endif /* _POSIX_SYS_POLL_H_ */
diff -Nur ../extras/mini-os/include/posix/syslog.h /root/extras/mini-os/include/posix/syslog.h
--- ../extras/mini-os/include/posix/syslog.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/posix/syslog.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,37 @@
+#ifndef _POSIX_SYSLOG_H
+#define _POSIX_SYSLOG_H
+
+#include <stdarg.h>
+
+#define LOG_PID 0
+#define LOG_CONS 0
+#define LOG_NDELAY 0
+#define LOG_ODELAY 0
+#define LOG_NOWAIT 0
+
+#define LOG_KERN 0
+#define LOG_USER 0
+#define LOG_MAIL 0
+#define LOG_NEWS 0
+#define LOG_UUCP 0
+#define LOG_DAEMON 0
+#define LOG_AUTH 0
+#define LOG_CRON 0
+#define LOG_LPR 0
+
+/* TODO: support */
+#define LOG_EMERG 0
+#define LOG_ALERT 1
+#define LOG_CRIT 2
+#define LOG_ERR 3
+#define LOG_WARNING 4
+#define LOG_NOTICE 5
+#define LOG_INFO 6
+#define LOG_DEBUG 7
+
+void openlog(const char *ident, int option, int facility);
+void syslog(int priority, const char *format, ...);
+void closelog(void);
+void vsyslog(int priority, const char *format, va_list ap);
+
+#endif /* _POSIX_SYSLOG_H */
diff -Nur ../extras/mini-os/include/posix/time.h /root/extras/mini-os/include/posix/time.h
--- ../extras/mini-os/include/posix/time.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/posix/time.h	2009-06-04 22:55:12.000000000 +0800
@@ -6,5 +6,6 @@
 #include_next <time.h>
 
 int nanosleep(const struct timespec *req, struct timespec *rem);
+int clock_gettime(clockid_t clock_id, struct timespec *tp);
 
 #endif /* _POSIX_TIME_H */
diff -Nur ../extras/mini-os/include/posix/unistd.h /root/extras/mini-os/include/posix/unistd.h
--- ../extras/mini-os/include/posix/unistd.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/posix/unistd.h	2009-06-04 22:55:12.000000000 +0800
@@ -5,5 +5,6 @@
 
 size_t getpagesize(void);
 int ftruncate(int fd, off_t length);
+int lockf(int fd, int cmd, off_t len);
 
 #endif /* _POSIX_UNISTD_H */
diff -Nur ../extras/mini-os/include/sched.h /root/extras/mini-os/include/sched.h
--- ../extras/mini-os/include/sched.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/sched.h	2009-06-19 15:43:04.000000000 +0800
@@ -10,6 +10,7 @@
 
 struct thread
 {
+    u32 tid;
     char *name;
     char *stack;
 #if !defined(__ia64__)
@@ -31,6 +32,11 @@
 void idle_thread_fn(void *unused);
 
 #define RUNNABLE_FLAG   0x00000001
+#define ALIVE_FLAG	0x10000000
+
+#define is_alive(_thread)	(_thread->flags & ALIVE_FLAG)
+#define set_alive(_thread)	(_thread->flags |= ALIVE_FLAG)
+#define clear_alive(_thread)	(_thread->flags &= ~ALIVE_FLAG)
 
 #define is_runnable(_thread)    (_thread->flags & RUNNABLE_FLAG)
 #define set_runnable(_thread)   (_thread->flags |= RUNNABLE_FLAG)
@@ -47,9 +53,12 @@
 struct thread* create_thread(char *name, void (*function)(void *), void *data);
 void exit_thread(void) __attribute__((noreturn));
 void schedule(void);
+void print_runqueue(void);
+struct thread *get_thread_byid(int tid);
 
+#ifdef __INSIDE_MINIOS__
 #define current get_current()
-
+#endif
 
 void wake(struct thread *thread);
 void block(struct thread *thread);
diff -Nur ../extras/mini-os/include/wait.h /root/extras/mini-os/include/wait.h
--- ../extras/mini-os/include/wait.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/wait.h	2009-06-04 22:55:12.000000000 +0800
@@ -7,7 +7,7 @@
 
 #define DEFINE_WAIT(name)                               \
 struct wait_queue name = {                              \
-    .thread       = current,                            \
+    .thread       = get_current(),                            \
     .thread_list  = MINIOS_LIST_HEAD_INIT((name).thread_list), \
 }
 
@@ -53,7 +53,7 @@
     unsigned long flags;        \
     local_irq_save(flags);      \
     add_wait_queue(&wq, &w);    \
-    block(current);             \
+    block(get_current());       \
     local_irq_restore(flags);   \
 } while (0)
 
@@ -74,8 +74,8 @@
         /* protect the list */                                  \
         local_irq_save(flags);                                  \
         add_wait_queue(&wq, &__wait);                           \
-        current->wakeup_time = deadline;                        \
-        clear_runnable(current);                                \
+        get_current()->wakeup_time = deadline;                  \
+        clear_runnable(get_current());                          \
         local_irq_restore(flags);                               \
         if((condition) || (deadline && NOW() >= deadline))      \
             break;                                              \
@@ -83,7 +83,7 @@
     }                                                           \
     local_irq_save(flags);                                      \
     /* need to wake up */                                       \
-    wake(current);                                              \
+    wake(get_current());                                        \
     remove_wait_queue(&__wait);                                 \
     local_irq_restore(flags);                                   \
 } while(0) 
diff -Nur ../extras/mini-os/include/x86/arch_mm.h /root/extras/mini-os/include/x86/arch_mm.h
--- ../extras/mini-os/include/x86/arch_mm.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/x86/arch_mm.h	2009-06-04 22:55:12.000000000 +0800
@@ -133,6 +133,13 @@
 #define L4_PROT (_PAGE_PRESENT|_PAGE_RW|_PAGE_ACCESSED|_PAGE_DIRTY|_PAGE_USER)
 #endif /* __i386__ || __x86_64__ */
 
+/* flags for ioremap */
+#define IO_PROT (L1_PROT)
+#define IO_PROT_NOCACHE (L1_PROT | _PAGE_PCD)
+
+/* for P2M */
+#define INVALID_P2M_ENTRY (~0UL)
+
 #include "arch_limits.h"
 #define PAGE_SIZE       __PAGE_SIZE
 #define PAGE_SHIFT      __PAGE_SHIFT
@@ -222,5 +229,6 @@
 #define do_map_zero(start, n) do_map_frames(start, &mfn_zero, n, 0, 0, DOMID_SELF, 0, L1_PROT_RO)
 
 pgentry_t *need_pgt(unsigned long addr);
+int mfn_is_ram(unsigned long mfn);
 
 #endif /* _ARCH_MM_H_ */
diff -Nur ../extras/mini-os/include/x86/domctl.h /root/extras/mini-os/include/x86/domctl.h
--- ../extras/mini-os/include/x86/domctl.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/x86/domctl.h	2009-06-05 09:49:02.000000000 +0800
@@ -0,0 +1,681 @@
+/******************************************************************************
+ * domctl.h
+ * 
+ * Domain management operations. For use by node control stack.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright (c) 2002-2003, B Dragovic
+ * Copyright (c) 2002-2006, K Fraser
+ */
+
+#ifndef __XEN_PUBLIC_DOMCTL_H__
+#define __XEN_PUBLIC_DOMCTL_H__
+
+/*#if !defined(__XEN__) && !defined(__XEN_TOOLS__)
+#error "domctl operations are intended for use by node control tools only"
+#endif
+*/
+
+#include <xen/xen.h>
+
+#define XEN_DOMCTL_INTERFACE_VERSION 0x00000005
+
+struct xenctl_cpumap {
+    XEN_GUEST_HANDLE_64(uint8) bitmap;
+    uint32_t nr_cpus;
+};
+
+/*
+ * NB. xen_domctl.domain is an IN/OUT parameter for this operation.
+ * If it is specified as zero, an id is auto-allocated and returned.
+ */
+#define XEN_DOMCTL_createdomain       1
+struct xen_domctl_createdomain {
+    /* IN parameters */
+    uint32_t ssidref;
+    xen_domain_handle_t handle;
+ /* Is this an HVM guest (as opposed to a PV guest)? */
+#define _XEN_DOMCTL_CDF_hvm_guest 0
+#define XEN_DOMCTL_CDF_hvm_guest  (1U<<_XEN_DOMCTL_CDF_hvm_guest)
+ /* Use hardware-assisted paging if available? */
+#define _XEN_DOMCTL_CDF_hap       1
+#define XEN_DOMCTL_CDF_hap        (1U<<_XEN_DOMCTL_CDF_hap)
+    uint32_t flags;
+};
+typedef struct xen_domctl_createdomain xen_domctl_createdomain_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_createdomain_t);
+
+#define XEN_DOMCTL_destroydomain      2
+#define XEN_DOMCTL_pausedomain        3
+#define XEN_DOMCTL_unpausedomain      4
+#define XEN_DOMCTL_resumedomain      27
+
+#define XEN_DOMCTL_getdomaininfo      5
+struct xen_domctl_getdomaininfo {
+    /* OUT variables. */
+    domid_t  domain;              /* Also echoed in domctl.domain */
+ /* Domain is scheduled to die. */
+#define _XEN_DOMINF_dying     0
+#define XEN_DOMINF_dying      (1U<<_XEN_DOMINF_dying)
+ /* Domain is an HVM guest (as opposed to a PV guest). */
+#define _XEN_DOMINF_hvm_guest 1
+#define XEN_DOMINF_hvm_guest  (1U<<_XEN_DOMINF_hvm_guest)
+ /* The guest OS has shut down. */
+#define _XEN_DOMINF_shutdown  2
+#define XEN_DOMINF_shutdown   (1U<<_XEN_DOMINF_shutdown)
+ /* Currently paused by control software. */
+#define _XEN_DOMINF_paused    3
+#define XEN_DOMINF_paused     (1U<<_XEN_DOMINF_paused)
+ /* Currently blocked pending an event.     */
+#define _XEN_DOMINF_blocked   4
+#define XEN_DOMINF_blocked    (1U<<_XEN_DOMINF_blocked)
+ /* Domain is currently running.            */
+#define _XEN_DOMINF_running   5
+#define XEN_DOMINF_running    (1U<<_XEN_DOMINF_running)
+ /* Being debugged.  */
+#define _XEN_DOMINF_debugged  6
+#define XEN_DOMINF_debugged   (1U<<_XEN_DOMINF_debugged)
+ /* CPU to which this domain is bound.      */
+#define XEN_DOMINF_cpumask      255
+#define XEN_DOMINF_cpushift       8
+ /* XEN_DOMINF_shutdown guest-supplied code.  */
+#define XEN_DOMINF_shutdownmask 255
+#define XEN_DOMINF_shutdownshift 16
+    uint32_t flags;              /* XEN_DOMINF_* */
+    uint64_aligned_t tot_pages;
+    uint64_aligned_t max_pages;
+    uint64_aligned_t shared_info_frame; /* GMFN of shared_info struct */
+    uint64_aligned_t cpu_time;
+    uint32_t nr_online_vcpus;    /* Number of VCPUs currently online. */
+    uint32_t max_vcpu_id;        /* Maximum VCPUID in use by this domain. */
+    uint32_t ssidref;
+    xen_domain_handle_t handle;
+};
+typedef struct xen_domctl_getdomaininfo xen_domctl_getdomaininfo_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_getdomaininfo_t);
+
+
+#define XEN_DOMCTL_getmemlist         6
+struct xen_domctl_getmemlist {
+    /* IN variables. */
+    /* Max entries to write to output buffer. */
+    uint64_aligned_t max_pfns;
+    /* Start index in guest's page list. */
+    uint64_aligned_t start_pfn;
+    XEN_GUEST_HANDLE_64(uint64) buffer;
+    /* OUT variables. */
+    uint64_aligned_t num_pfns;
+};
+typedef struct xen_domctl_getmemlist xen_domctl_getmemlist_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_getmemlist_t);
+
+
+#define XEN_DOMCTL_getpageframeinfo   7
+
+#define XEN_DOMCTL_PFINFO_LTAB_SHIFT 28
+#define XEN_DOMCTL_PFINFO_NOTAB   (0x0U<<28)
+#define XEN_DOMCTL_PFINFO_L1TAB   (0x1U<<28)
+#define XEN_DOMCTL_PFINFO_L2TAB   (0x2U<<28)
+#define XEN_DOMCTL_PFINFO_L3TAB   (0x3U<<28)
+#define XEN_DOMCTL_PFINFO_L4TAB   (0x4U<<28)
+#define XEN_DOMCTL_PFINFO_LTABTYPE_MASK (0x7U<<28)
+#define XEN_DOMCTL_PFINFO_LPINTAB (0x1U<<31)
+#define XEN_DOMCTL_PFINFO_XTAB    (0xfU<<28) /* invalid page */
+#define XEN_DOMCTL_PFINFO_LTAB_MASK (0xfU<<28)
+
+struct xen_domctl_getpageframeinfo {
+    /* IN variables. */
+    uint64_aligned_t gmfn; /* GMFN to query */
+    /* OUT variables. */
+    /* Is the page PINNED to a type? */
+    uint32_t type;         /* see above type defs */
+};
+typedef struct xen_domctl_getpageframeinfo xen_domctl_getpageframeinfo_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_getpageframeinfo_t);
+
+
+#define XEN_DOMCTL_getpageframeinfo2  8
+struct xen_domctl_getpageframeinfo2 {
+    /* IN variables. */
+    uint64_aligned_t num;
+    /* IN/OUT variables. */
+    XEN_GUEST_HANDLE_64(uint32) array;
+};
+typedef struct xen_domctl_getpageframeinfo2 xen_domctl_getpageframeinfo2_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_getpageframeinfo2_t);
+
+
+/*
+ * Control shadow pagetables operation
+ */
+#define XEN_DOMCTL_shadow_op         10
+
+/* Disable shadow mode. */
+#define XEN_DOMCTL_SHADOW_OP_OFF         0
+
+/* Enable shadow mode (mode contains ORed XEN_DOMCTL_SHADOW_ENABLE_* flags). */
+#define XEN_DOMCTL_SHADOW_OP_ENABLE      32
+
+/* Log-dirty bitmap operations. */
+ /* Return the bitmap and clean internal copy for next round. */
+#define XEN_DOMCTL_SHADOW_OP_CLEAN       11
+ /* Return the bitmap but do not modify internal copy. */
+#define XEN_DOMCTL_SHADOW_OP_PEEK        12
+
+/* Memory allocation accessors. */
+#define XEN_DOMCTL_SHADOW_OP_GET_ALLOCATION   30
+#define XEN_DOMCTL_SHADOW_OP_SET_ALLOCATION   31
+
+/* Legacy enable operations. */
+ /* Equiv. to ENABLE with no mode flags. */
+#define XEN_DOMCTL_SHADOW_OP_ENABLE_TEST       1
+ /* Equiv. to ENABLE with mode flag ENABLE_LOG_DIRTY. */
+#define XEN_DOMCTL_SHADOW_OP_ENABLE_LOGDIRTY   2
+ /* Equiv. to ENABLE with mode flags ENABLE_REFCOUNT and ENABLE_TRANSLATE. */
+#define XEN_DOMCTL_SHADOW_OP_ENABLE_TRANSLATE  3
+
+/* Mode flags for XEN_DOMCTL_SHADOW_OP_ENABLE. */
+ /*
+  * Shadow pagetables are refcounted: guest does not use explicit mmu
+  * operations nor write-protect its pagetables.
+  */
+#define XEN_DOMCTL_SHADOW_ENABLE_REFCOUNT  (1 << 1)
+ /*
+  * Log pages in a bitmap as they are dirtied.
+  * Used for live relocation to determine which pages must be re-sent.
+  */
+#define XEN_DOMCTL_SHADOW_ENABLE_LOG_DIRTY (1 << 2)
+ /*
+  * Automatically translate GPFNs into MFNs.
+  */
+#define XEN_DOMCTL_SHADOW_ENABLE_TRANSLATE (1 << 3)
+ /*
+  * Xen does not steal virtual address space from the guest.
+  * Requires HVM support.
+  */
+#define XEN_DOMCTL_SHADOW_ENABLE_EXTERNAL  (1 << 4)
+
+struct xen_domctl_shadow_op_stats {
+    uint32_t fault_count;
+    uint32_t dirty_count;
+};
+typedef struct xen_domctl_shadow_op_stats xen_domctl_shadow_op_stats_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_shadow_op_stats_t);
+
+struct xen_domctl_shadow_op {
+    /* IN variables. */
+    uint32_t       op;       /* XEN_DOMCTL_SHADOW_OP_* */
+
+    /* OP_ENABLE */
+    uint32_t       mode;     /* XEN_DOMCTL_SHADOW_ENABLE_* */
+
+    /* OP_GET_ALLOCATION / OP_SET_ALLOCATION */
+    uint32_t       mb;       /* Shadow memory allocation in MB */
+
+    /* OP_PEEK / OP_CLEAN */
+    XEN_GUEST_HANDLE_64(uint8) dirty_bitmap;
+    uint64_aligned_t pages; /* Size of buffer. Updated with actual size. */
+    struct xen_domctl_shadow_op_stats stats;
+};
+typedef struct xen_domctl_shadow_op xen_domctl_shadow_op_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_shadow_op_t);
+
+
+#define XEN_DOMCTL_max_mem           11
+struct xen_domctl_max_mem {
+    /* IN variables. */
+    uint64_aligned_t max_memkb;
+};
+typedef struct xen_domctl_max_mem xen_domctl_max_mem_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_max_mem_t);
+
+
+#define XEN_DOMCTL_setvcpucontext    12
+#define XEN_DOMCTL_getvcpucontext    13
+struct xen_domctl_vcpucontext {
+    uint32_t              vcpu;                  /* IN */
+    XEN_GUEST_HANDLE_64(vcpu_guest_context_t) ctxt; /* IN/OUT */
+};
+typedef struct xen_domctl_vcpucontext xen_domctl_vcpucontext_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_vcpucontext_t);
+
+
+#define XEN_DOMCTL_getvcpuinfo       14
+struct xen_domctl_getvcpuinfo {
+    /* IN variables. */
+    uint32_t vcpu;
+    /* OUT variables. */
+    uint8_t  online;                  /* currently online (not hotplugged)? */
+    uint8_t  blocked;                 /* blocked waiting for an event? */
+    uint8_t  running;                 /* currently scheduled on its CPU? */
+    uint64_aligned_t cpu_time;        /* total cpu time consumed (ns) */
+    uint32_t cpu;                     /* current mapping   */
+};
+typedef struct xen_domctl_getvcpuinfo xen_domctl_getvcpuinfo_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_getvcpuinfo_t);
+
+
+/* Get/set which physical cpus a vcpu can execute on. */
+#define XEN_DOMCTL_setvcpuaffinity    9
+#define XEN_DOMCTL_getvcpuaffinity   25
+struct xen_domctl_vcpuaffinity {
+    uint32_t  vcpu;              /* IN */
+    struct xenctl_cpumap cpumap; /* IN/OUT */
+};
+typedef struct xen_domctl_vcpuaffinity xen_domctl_vcpuaffinity_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_vcpuaffinity_t);
+
+
+#define XEN_DOMCTL_max_vcpus         15
+struct xen_domctl_max_vcpus {
+    uint32_t max;           /* maximum number of vcpus */
+};
+typedef struct xen_domctl_max_vcpus xen_domctl_max_vcpus_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_max_vcpus_t);
+
+
+#define XEN_DOMCTL_scheduler_op      16
+/* Scheduler types. */
+#define XEN_SCHEDULER_SEDF     4
+#define XEN_SCHEDULER_CREDIT   5
+/* Set or get info? */
+#define XEN_DOMCTL_SCHEDOP_putinfo 0
+#define XEN_DOMCTL_SCHEDOP_getinfo 1
+struct xen_domctl_scheduler_op {
+    uint32_t sched_id;  /* XEN_SCHEDULER_* */
+    uint32_t cmd;       /* XEN_DOMCTL_SCHEDOP_* */
+    union {
+        struct xen_domctl_sched_sedf {
+            uint64_aligned_t period;
+            uint64_aligned_t slice;
+            uint64_aligned_t latency;
+            uint32_t extratime;
+            uint32_t weight;
+        } sedf;
+        struct xen_domctl_sched_credit {
+            uint16_t weight;
+            uint16_t cap;
+        } credit;
+    } u;
+};
+typedef struct xen_domctl_scheduler_op xen_domctl_scheduler_op_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_scheduler_op_t);
+
+
+#define XEN_DOMCTL_setdomainhandle   17
+struct xen_domctl_setdomainhandle {
+    xen_domain_handle_t handle;
+};
+typedef struct xen_domctl_setdomainhandle xen_domctl_setdomainhandle_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_setdomainhandle_t);
+
+
+#define XEN_DOMCTL_setdebugging      18
+struct xen_domctl_setdebugging {
+    uint8_t enable;
+};
+typedef struct xen_domctl_setdebugging xen_domctl_setdebugging_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_setdebugging_t);
+
+
+#define XEN_DOMCTL_irq_permission    19
+struct xen_domctl_irq_permission {
+    uint8_t pirq;
+    uint8_t allow_access;    /* flag to specify enable/disable of IRQ access */
+};
+typedef struct xen_domctl_irq_permission xen_domctl_irq_permission_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_irq_permission_t);
+
+
+#define XEN_DOMCTL_iomem_permission  20
+struct xen_domctl_iomem_permission {
+    uint64_aligned_t first_mfn;/* first page (physical page number) in range */
+    uint64_aligned_t nr_mfns;  /* number of pages in range (>0) */
+    uint8_t  allow_access;     /* allow (!0) or deny (0) access to range? */
+};
+typedef struct xen_domctl_iomem_permission xen_domctl_iomem_permission_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_iomem_permission_t);
+
+
+#define XEN_DOMCTL_ioport_permission 21
+struct xen_domctl_ioport_permission {
+    uint32_t first_port;              /* first port int range */
+    uint32_t nr_ports;                /* size of port range */
+    uint8_t  allow_access;            /* allow or deny access to range? */
+};
+typedef struct xen_domctl_ioport_permission xen_domctl_ioport_permission_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_ioport_permission_t);
+
+
+#define XEN_DOMCTL_hypercall_init    22
+struct xen_domctl_hypercall_init {
+    uint64_aligned_t  gmfn;           /* GMFN to be initialised */
+};
+typedef struct xen_domctl_hypercall_init xen_domctl_hypercall_init_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_hypercall_init_t);
+
+
+#define XEN_DOMCTL_arch_setup        23
+#define _XEN_DOMAINSETUP_hvm_guest 0
+#define XEN_DOMAINSETUP_hvm_guest  (1UL<<_XEN_DOMAINSETUP_hvm_guest)
+#define _XEN_DOMAINSETUP_query 1 /* Get parameters (for save)  */
+#define XEN_DOMAINSETUP_query  (1UL<<_XEN_DOMAINSETUP_query)
+#define _XEN_DOMAINSETUP_sioemu_guest 2
+#define XEN_DOMAINSETUP_sioemu_guest  (1UL<<_XEN_DOMAINSETUP_sioemu_guest)
+typedef struct xen_domctl_arch_setup {
+    uint64_aligned_t flags;  /* XEN_DOMAINSETUP_* */
+#ifdef __ia64__
+    uint64_aligned_t bp;     /* mpaddr of boot param area */
+    uint64_aligned_t maxmem; /* Highest memory address for MDT.  */
+    uint64_aligned_t xsi_va; /* Xen shared_info area virtual address.  */
+    uint32_t hypercall_imm;  /* Break imm for Xen hypercalls.  */
+    int8_t vhpt_size_log2;   /* Log2 of VHPT size. */
+#endif
+} xen_domctl_arch_setup_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_arch_setup_t);
+
+
+#define XEN_DOMCTL_settimeoffset     24
+struct xen_domctl_settimeoffset {
+    int32_t  time_offset_seconds; /* applied to domain wallclock time */
+};
+typedef struct xen_domctl_settimeoffset xen_domctl_settimeoffset_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_settimeoffset_t);
+
+ 
+#define XEN_DOMCTL_gethvmcontext     33
+#define XEN_DOMCTL_sethvmcontext     34
+typedef struct xen_domctl_hvmcontext {
+    uint32_t size; /* IN/OUT: size of buffer / bytes filled */
+    XEN_GUEST_HANDLE_64(uint8) buffer; /* IN/OUT: data, or call
+                                        * gethvmcontext with NULL
+                                        * buffer to get size req'd */
+} xen_domctl_hvmcontext_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_hvmcontext_t);
+
+
+#define XEN_DOMCTL_set_address_size  35
+#define XEN_DOMCTL_get_address_size  36
+typedef struct xen_domctl_address_size {
+    uint32_t size;
+} xen_domctl_address_size_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_address_size_t);
+
+
+#define XEN_DOMCTL_real_mode_area    26
+struct xen_domctl_real_mode_area {
+    uint32_t log; /* log2 of Real Mode Area size */
+};
+typedef struct xen_domctl_real_mode_area xen_domctl_real_mode_area_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_real_mode_area_t);
+
+
+#define XEN_DOMCTL_sendtrigger       28
+#define XEN_DOMCTL_SENDTRIGGER_NMI    0
+#define XEN_DOMCTL_SENDTRIGGER_RESET  1
+#define XEN_DOMCTL_SENDTRIGGER_INIT   2
+struct xen_domctl_sendtrigger {
+    uint32_t  trigger;  /* IN */
+    uint32_t  vcpu;     /* IN */
+};
+typedef struct xen_domctl_sendtrigger xen_domctl_sendtrigger_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_sendtrigger_t);
+
+
+/* Assign PCI device to HVM guest. Sets up IOMMU structures. */
+#define XEN_DOMCTL_assign_device      37
+#define XEN_DOMCTL_test_assign_device 45
+#define XEN_DOMCTL_deassign_device 47
+struct xen_domctl_assign_device {
+    uint32_t  machine_bdf;   /* machine PCI ID of assigned device */
+};
+typedef struct xen_domctl_assign_device xen_domctl_assign_device_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_assign_device_t);
+
+/* Retrieve sibling devices infomation of machine_bdf */
+#define XEN_DOMCTL_get_device_group 50
+struct xen_domctl_get_device_group {
+    uint32_t  machine_bdf;      /* IN */
+    uint32_t  max_sdevs;        /* IN */
+    uint32_t  num_sdevs;        /* OUT */
+    XEN_GUEST_HANDLE_64(uint32)  sdev_array;   /* OUT */
+};
+typedef struct xen_domctl_get_device_group xen_domctl_get_device_group_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_get_device_group_t);
+
+/* Pass-through interrupts: bind real irq -> hvm devfn. */
+#define XEN_DOMCTL_bind_pt_irq       38
+#define XEN_DOMCTL_unbind_pt_irq     48
+typedef enum pt_irq_type_e {
+    PT_IRQ_TYPE_PCI,
+    PT_IRQ_TYPE_ISA,
+    PT_IRQ_TYPE_MSI,
+} pt_irq_type_t;
+struct xen_domctl_bind_pt_irq {
+    uint32_t machine_irq;
+    pt_irq_type_t irq_type;
+    uint32_t hvm_domid;
+
+    union {
+        struct {
+            uint8_t isa_irq;
+        } isa;
+        struct {
+            uint8_t bus;
+            uint8_t device;
+            uint8_t intx;
+        } pci;
+        struct {
+            uint8_t gvec;
+            uint32_t gflags;
+        } msi;
+    } u;
+};
+typedef struct xen_domctl_bind_pt_irq xen_domctl_bind_pt_irq_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_bind_pt_irq_t);
+
+
+/* Bind machine I/O address range -> HVM address range. */
+#define XEN_DOMCTL_memory_mapping    39
+#define DPCI_ADD_MAPPING         1
+#define DPCI_REMOVE_MAPPING      0
+struct xen_domctl_memory_mapping {
+    uint64_aligned_t first_gfn; /* first page (hvm guest phys page) in range */
+    uint64_aligned_t first_mfn; /* first page (machine page) in range */
+    uint64_aligned_t nr_mfns;   /* number of pages in range (>0) */
+    uint32_t add_mapping;       /* add or remove mapping */
+    uint32_t padding;           /* padding for 64-bit aligned structure */
+};
+typedef struct xen_domctl_memory_mapping xen_domctl_memory_mapping_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_memory_mapping_t);
+
+
+/* Bind machine I/O port range -> HVM I/O port range. */
+#define XEN_DOMCTL_ioport_mapping    40
+struct xen_domctl_ioport_mapping {
+    uint32_t first_gport;     /* first guest IO port*/
+    uint32_t first_mport;     /* first machine IO port */
+    uint32_t nr_ports;        /* size of port range */
+    uint32_t add_mapping;     /* add or remove mapping */
+};
+typedef struct xen_domctl_ioport_mapping xen_domctl_ioport_mapping_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_ioport_mapping_t);
+
+
+/*
+ * Pin caching type of RAM space for x86 HVM domU.
+ */
+#define XEN_DOMCTL_pin_mem_cacheattr 41
+/* Caching types: these happen to be the same as x86 MTRR/PAT type codes. */
+#define XEN_DOMCTL_MEM_CACHEATTR_UC  0
+#define XEN_DOMCTL_MEM_CACHEATTR_WC  1
+#define XEN_DOMCTL_MEM_CACHEATTR_WT  4
+#define XEN_DOMCTL_MEM_CACHEATTR_WP  5
+#define XEN_DOMCTL_MEM_CACHEATTR_WB  6
+#define XEN_DOMCTL_MEM_CACHEATTR_UCM 7
+struct xen_domctl_pin_mem_cacheattr {
+    uint64_aligned_t start, end;
+    unsigned int type; /* XEN_DOMCTL_MEM_CACHEATTR_* */
+};
+typedef struct xen_domctl_pin_mem_cacheattr xen_domctl_pin_mem_cacheattr_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_pin_mem_cacheattr_t);
+
+
+#define XEN_DOMCTL_set_ext_vcpucontext 42
+#define XEN_DOMCTL_get_ext_vcpucontext 43
+struct xen_domctl_ext_vcpucontext {
+    /* IN: VCPU that this call applies to. */
+    uint32_t         vcpu;
+    /*
+     * SET: Size of struct (IN)
+     * GET: Size of struct (OUT)
+     */
+    uint32_t         size;
+#if defined(__i386__) || defined(__x86_64__)
+    /* SYSCALL from 32-bit mode and SYSENTER callback information. */
+    /* NB. SYSCALL from 64-bit mode is contained in vcpu_guest_context_t */
+    uint64_aligned_t syscall32_callback_eip;
+    uint64_aligned_t sysenter_callback_eip;
+    uint16_t         syscall32_callback_cs;
+    uint16_t         sysenter_callback_cs;
+    uint8_t          syscall32_disables_events;
+    uint8_t          sysenter_disables_events;
+#endif
+};
+typedef struct xen_domctl_ext_vcpucontext xen_domctl_ext_vcpucontext_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_ext_vcpucontext_t);
+
+/*
+ * Set optimizaton features for a domain
+ */
+#define XEN_DOMCTL_set_opt_feature    44
+struct xen_domctl_set_opt_feature {
+#if defined(__ia64__)
+    struct xen_ia64_opt_feature optf;
+#else
+    /* Make struct non-empty: do not depend on this field name! */
+    uint64_t dummy;
+#endif
+};
+typedef struct xen_domctl_set_opt_feature xen_domctl_set_opt_feature_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_set_opt_feature_t);
+
+/*
+ * Set the target domain for a domain
+ */
+#define XEN_DOMCTL_set_target    46
+struct xen_domctl_set_target {
+    domid_t target;
+};
+typedef struct xen_domctl_set_target xen_domctl_set_target_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_set_target_t);
+
+#if defined(__i386__) || defined(__x86_64__)
+# define XEN_CPUID_INPUT_UNUSED  0xFFFFFFFF
+# define XEN_DOMCTL_set_cpuid 49
+struct xen_domctl_cpuid {
+  unsigned int  input[2];
+  unsigned int  eax;
+  unsigned int  ebx;
+  unsigned int  ecx;
+  unsigned int  edx;
+};
+typedef struct xen_domctl_cpuid xen_domctl_cpuid_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_cpuid_t);
+#endif
+
+#define XEN_DOMCTL_subscribe          29
+struct xen_domctl_subscribe {
+    uint32_t port; /* IN */
+};
+typedef struct xen_domctl_subscribe xen_domctl_subscribe_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_subscribe_t);
+
+/*
+ * Define the maximum machine address size which should be allocated
+ * to a guest.
+ */
+#define XEN_DOMCTL_set_machine_address_size  51
+#define XEN_DOMCTL_get_machine_address_size  52
+
+/*
+ * Do not inject spurious page faults into this domain.
+ */
+#define XEN_DOMCTL_suppress_spurious_page_faults 53
+
+struct xen_domctl {
+    uint32_t cmd;
+    uint32_t interface_version; /* XEN_DOMCTL_INTERFACE_VERSION */
+    domid_t  domain;
+    union {
+        struct xen_domctl_createdomain      createdomain;
+        struct xen_domctl_getdomaininfo     getdomaininfo;
+        struct xen_domctl_getmemlist        getmemlist;
+        struct xen_domctl_getpageframeinfo  getpageframeinfo;
+        struct xen_domctl_getpageframeinfo2 getpageframeinfo2;
+        struct xen_domctl_vcpuaffinity      vcpuaffinity;
+        struct xen_domctl_shadow_op         shadow_op;
+        struct xen_domctl_max_mem           max_mem;
+        struct xen_domctl_vcpucontext       vcpucontext;
+        struct xen_domctl_getvcpuinfo       getvcpuinfo;
+        struct xen_domctl_max_vcpus         max_vcpus;
+        struct xen_domctl_scheduler_op      scheduler_op;
+        struct xen_domctl_setdomainhandle   setdomainhandle;
+        struct xen_domctl_setdebugging      setdebugging;
+        struct xen_domctl_irq_permission    irq_permission;
+        struct xen_domctl_iomem_permission  iomem_permission;
+        struct xen_domctl_ioport_permission ioport_permission;
+        struct xen_domctl_hypercall_init    hypercall_init;
+        struct xen_domctl_arch_setup        arch_setup;
+        struct xen_domctl_settimeoffset     settimeoffset;
+        struct xen_domctl_real_mode_area    real_mode_area;
+        struct xen_domctl_hvmcontext        hvmcontext;
+        struct xen_domctl_address_size      address_size;
+        struct xen_domctl_sendtrigger       sendtrigger;
+        struct xen_domctl_get_device_group  get_device_group;
+        struct xen_domctl_assign_device     assign_device;
+        struct xen_domctl_bind_pt_irq       bind_pt_irq;
+        struct xen_domctl_memory_mapping    memory_mapping;
+        struct xen_domctl_ioport_mapping    ioport_mapping;
+        struct xen_domctl_pin_mem_cacheattr pin_mem_cacheattr;
+        struct xen_domctl_ext_vcpucontext   ext_vcpucontext;
+        struct xen_domctl_set_opt_feature   set_opt_feature;
+        struct xen_domctl_set_target        set_target;
+        struct xen_domctl_subscribe         subscribe;
+#if defined(__i386__) || defined(__x86_64__)
+        struct xen_domctl_cpuid             cpuid;
+#endif
+        uint8_t                             pad[128];
+    } u;
+};
+typedef struct xen_domctl xen_domctl_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_t);
+
+#endif /* __XEN_PUBLIC_DOMCTL_H__ */
+
+/*
+ * Local variables:
+ * mode: C
+ * c-set-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -Nur ../extras/mini-os/include/x86/os.h /root/extras/mini-os/include/x86/os.h
--- ../extras/mini-os/include/x86/os.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/x86/os.h	2009-06-04 22:55:12.000000000 +0800
@@ -11,6 +11,7 @@
 #define __builtin_expect(x, expected_value) (x)
 #endif
 #define unlikely(x)  __builtin_expect((x),0)
+#define likely(x)  __builtin_expect((x),1)
 
 #define smp_processor_id() 0
 
diff -Nur ../extras/mini-os/include/xenbus.h /root/extras/mini-os/include/xenbus.h
--- ../extras/mini-os/include/xenbus.h	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/include/xenbus.h	2009-06-04 22:55:12.000000000 +0800
@@ -83,12 +83,16 @@
 			     int *retry);
 
 /* Read path and parse it as an integer.  Returns -1 on error. */
-int xenbus_read_integer(char *path);
+int xenbus_read_integer(const char *path);
 
 /* Contraction of snprintf and xenbus_write(path/node). */
 char* xenbus_printf(xenbus_transaction_t xbt,
-                                  char* node, char* path,
-                                  char* fmt, ...);
+                                  const char* node, const char* path,
+                                  const char* fmt, ...)
+                   __attribute__((__format__(printf, 4, 5)));
+
+/* Utility function to figure out our domain id */
+domid_t xenbus_get_self_id(void);
 
 /* Reset the XenBus system. */
 void fini_xenbus(void);
diff -Nur ../extras/mini-os/include/xs.h /root/extras/mini-os/include/xs.h
--- ../extras/mini-os/include/xs.h	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/include/xs.h	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,182 @@
+/* 
+    Xen Store Daemon providing simple tree-like database.
+    Copyright (C) 2005 Rusty Russell IBM Corporation
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef _XS_H
+#define _XS_H
+
+#include <xs_lib.h>
+
+#define XBT_NULL 0
+
+struct xs_handle;
+typedef uint32_t xs_transaction_t;
+
+/* IMPORTANT: For details on xenstore protocol limits, see
+ * docs/misc/xenstore.txt in the Xen public source repository, and use the
+ * XENSTORE_*_MAX limit macros defined in xen/io/xs_wire.h.
+ */
+
+/* On failure, these routines set errno. */
+
+/* Connect to the xs daemon.
+ * Returns a handle or NULL.
+ */
+struct xs_handle *xs_daemon_open(void);
+struct xs_handle *xs_domain_open(void);
+
+/* Connect to the xs daemon (readonly for non-root clients).
+ * Returns a handle or NULL.
+ */
+struct xs_handle *xs_daemon_open_readonly(void);
+
+/* Close the connection to the xs daemon. */
+void xs_daemon_close(struct xs_handle *);
+
+/* Get contents of a directory.
+ * Returns a malloced array: call free() on it after use.
+ * Num indicates size.
+ */
+char **xs_directory(struct xs_handle *h, xs_transaction_t t,
+		    const char *path, unsigned int *num);
+
+/* Get the value of a single file, nul terminated.
+ * Returns a malloced value: call free() on it after use.
+ * len indicates length in bytes, not including terminator.
+ */
+void *xs_read(struct xs_handle *h, xs_transaction_t t,
+	      const char *path, unsigned int *len);
+
+/* Write the value of a single file.
+ * Returns false on failure.
+ */
+bool xs_write(struct xs_handle *h, xs_transaction_t t,
+	      const char *path, const void *data, unsigned int len);
+
+/* Create a new directory.
+ * Returns false on failure, or success if it already exists.
+ */
+bool xs_mkdir(struct xs_handle *h, xs_transaction_t t,
+	      const char *path);
+
+/* Destroy a file or directory (and children).
+ * Returns false on failure, or if it doesn't exist.
+ */
+bool xs_rm(struct xs_handle *h, xs_transaction_t t,
+	   const char *path);
+
+/* Get permissions of node (first element is owner, first perms is "other").
+ * Returns malloced array, or NULL: call free() after use.
+ */
+struct xs_permissions *xs_get_permissions(struct xs_handle *h,
+					  xs_transaction_t t,
+					  const char *path, unsigned int *num);
+
+/* Set permissions of node (must be owner).
+ * Returns false on failure.
+ */
+bool xs_set_permissions(struct xs_handle *h, xs_transaction_t t,
+			const char *path, struct xs_permissions *perms,
+			unsigned int num_perms);
+
+/* Watch a node for changes (poll on fd to detect, or call read_watch()).
+ * When the node (or any child) changes, fd will become readable.
+ * Token is returned when watch is read, to allow matching.
+ * Returns false on failure.
+ */
+bool xs_watch(struct xs_handle *h, const char *path, const char *token);
+
+/* Return the FD to poll on to see if a watch has fired. */
+int xs_fileno(struct xs_handle *h);
+
+/* Find out what node change was on (will block if nothing pending).
+ * Returns array containing the path and token. Use XS_WATCH_* to access these
+ * elements. Call free() after use.
+ */
+char **xs_read_watch(struct xs_handle *h, unsigned int *num);
+
+/* Remove a watch on a node: implicitly acks any outstanding watch.
+ * Returns false on failure (no watch on that node).
+ */
+bool xs_unwatch(struct xs_handle *h, const char *path, const char *token);
+
+/* Start a transaction: changes by others will not be seen during this
+ * transaction, and changes will not be visible to others until end.
+ * Returns NULL on failure.
+ */
+xs_transaction_t xs_transaction_start(struct xs_handle *h);
+
+/* End a transaction.
+ * If abandon is true, transaction is discarded instead of committed.
+ * Returns false on failure: if errno == EAGAIN, you have to restart
+ * transaction.
+ */
+bool xs_transaction_end(struct xs_handle *h, xs_transaction_t t,
+			bool abort);
+
+/* Introduce a new domain.
+ * This tells the store daemon about a shared memory page, event channel and
+ * store path associated with a domain: the domain uses these to communicate.
+ */
+bool xs_introduce_domain(struct xs_handle *h,
+			 unsigned int domid,
+			 unsigned long mfn,
+                         unsigned int eventchn); 
+
+/* Set the target of a domain
+ * This tells the store daemon that a domain is targetting another one, so
+ * it should let it tinker with it.
+ */
+bool xs_set_target(struct xs_handle *h,
+		   unsigned int domid,
+		   unsigned int target);
+
+/* Resume a domain.
+ * Clear the shutdown flag for this domain in the store.
+ */
+bool xs_resume_domain(struct xs_handle *h, unsigned int domid);
+
+/* Release a domain.
+ * Tells the store domain to release the memory page to the domain.
+ */
+bool xs_release_domain(struct xs_handle *h, unsigned int domid);
+
+/* Query the home path of a domain.  Call free() after use.
+ */
+char *xs_get_domain_path(struct xs_handle *h, unsigned int domid);
+
+/* Return whether the domain specified has been introduced to xenstored.
+ */
+bool xs_is_domain_introduced(struct xs_handle *h, unsigned int domid);
+
+/* Only useful for DEBUG versions */
+char *xs_debug_command(struct xs_handle *h, const char *cmd,
+		       void *data, unsigned int len);
+
+int xs_suspend_evtchn_port(int domid);
+#endif /* _XS_H */
+
+/*
+ * Local variables:
+ *  c-file-style: "linux"
+ *  indent-tabs-mode: t
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
diff -Nur ../extras/mini-os/kernel.c /root/extras/mini-os/kernel.c
--- ../extras/mini-os/kernel.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/kernel.c	2009-06-04 22:55:12.000000000 +0800
@@ -490,14 +490,16 @@
 
     /* print out some useful information  */
     printk("Xen Minimal OS!\n");
-    printk("start_info:   %p\n",    si);
-    printk("  nr_pages:   %lu",     si->nr_pages);
-    printk("  shared_inf: %08lx\n", si->shared_info);
-    printk("  pt_base:    %p",      (void *)si->pt_base); 
-    printk("  mod_start:  0x%lx\n", si->mod_start);
-    printk("  mod_len:    %lu\n",   si->mod_len); 
-    printk("  flags:      0x%x\n",  (unsigned int)si->flags);
-    printk("  cmd_line:   %s\n",  
+    printk("  start_info: %p(VA)\n", si);
+    printk("    nr_pages: 0x%lx\n", si->nr_pages);
+    printk("  shared_inf: 0x%08lx(MA)\n", si->shared_info);
+    printk("     pt_base: %p(VA)\n", (void *)si->pt_base); 
+    printk("nr_pt_frames: 0x%lx\n", si->nr_pt_frames);
+    printk("    mfn_list: %p(VA)\n", (void *)si->mfn_list); 
+    printk("   mod_start: 0x%lx(VA)\n", si->mod_start);
+    printk("     mod_len: %lu\n", si->mod_len); 
+    printk("       flags: 0x%x\n", (unsigned int)si->flags);
+    printk("    cmd_line: %s\n",  
            si->cmd_line ? (const char *)si->cmd_line : "NULL");
 
     /* Set up events. */
diff -Nur ../extras/mini-os/lib/stack_chk_fail.c /root/extras/mini-os/lib/stack_chk_fail.c
--- ../extras/mini-os/lib/stack_chk_fail.c	1970-01-01 08:00:00.000000000 +0800
+++ /root/extras/mini-os/lib/stack_chk_fail.c	2009-06-04 22:55:12.000000000 +0800
@@ -0,0 +1,8 @@
+#include <kernel.h>
+#include <console.h>
+
+void __stack_chk_fail(void)
+{
+    printk("stack smashing detected\n");
+    do_exit();
+}
diff -Nur ../extras/mini-os/lib/sys.c /root/extras/mini-os/lib/sys.c
--- ../extras/mini-os/lib/sys.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/lib/sys.c	2009-06-15 21:27:03.000000000 +0800
@@ -34,6 +34,7 @@
 #include <sys/unistd.h>
 #include <sys/stat.h>
 #include <sys/mman.h>
+#include <net/if.h>
 #include <time.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -210,6 +211,17 @@
     return files[fd].type == FTYPE_CONSOLE;
 }
 
+void print_back(char *buf,int len)
+{
+	if(len>0)
+	{
+		if(*buf==0x7f)
+			return;
+		buf[len]='\0';
+		printk("%s",buf);
+	}
+}
+
 int read(int fd, void *buf, size_t nbytes)
 {
     switch (files[fd].type) {
@@ -219,6 +231,7 @@
             while(1) {
                 add_waiter(w, console_queue);
                 ret = xencons_ring_recv(buf, nbytes);
+		print_back(buf,ret);
                 if (ret)
                     break;
                 schedule();
@@ -676,7 +689,7 @@
 {
     int i, n = 0;
 #ifdef HAVE_LWIP
-    int sock_n, sock_nfds = 0;
+    int sock_n = 0, sock_nfds = 0;
     fd_set sock_readfds, sock_writefds, sock_exceptfds;
     struct timeval timeout = { .tv_sec = 0, .tv_usec = 0};
 #endif
@@ -710,12 +723,14 @@
 	    }
 	}
     }
-    DEBUG("lwip_select(");
-    dump_set(nfds, &sock_readfds, &sock_writefds, &sock_exceptfds, &timeout);
-    DEBUG("); -> ");
-    sock_n = lwip_select(sock_nfds, &sock_readfds, &sock_writefds, &sock_exceptfds, &timeout);
-    dump_set(nfds, &sock_readfds, &sock_writefds, &sock_exceptfds, &timeout);
-    DEBUG("\n");
+    if (sock_nfds > 0) {
+        DEBUG("lwip_select(");
+        dump_set(nfds, &sock_readfds, &sock_writefds, &sock_exceptfds, &timeout);
+        DEBUG("); -> ");
+        sock_n = lwip_select(sock_nfds, &sock_readfds, &sock_writefds, &sock_exceptfds, &timeout);
+        dump_set(nfds, &sock_readfds, &sock_writefds, &sock_exceptfds, &timeout);
+        DEBUG("\n");
+    }
 #endif
 
     /* Then see others as well. */
@@ -1007,6 +1022,96 @@
 LWIP_STUB(int, getsockname, (int s, struct sockaddr *name, socklen_t *namelen), (s, name, namelen))
 #endif
 
+static char *syslog_ident;
+void openlog(const char *ident, int option, int facility)
+{
+    if (syslog_ident)
+        free(syslog_ident);
+    syslog_ident = strdup(ident);
+}
+
+void vsyslog(int priority, const char *format, va_list ap)
+{
+    printk("%s: ", syslog_ident);
+    print(0, format, ap);
+}
+
+void syslog(int priority, const char *format, ...)
+{
+    va_list ap;
+    va_start(ap, format);
+    vsyslog(priority, format, ap);
+    va_end(ap);
+}
+
+void closelog(void)
+{
+    free(syslog_ident);
+    syslog_ident = NULL;
+}
+
+void vwarn(const char *format, va_list ap)
+{
+    int the_errno = errno;
+    printk("stubdom: ");
+    if (format) {
+        print(0, format, ap);
+        printk(", ");
+    }
+    printk("%s", strerror(the_errno));
+}
+
+void warn(const char *format, ...)
+{
+    va_list ap;
+    va_start(ap, format);
+    vwarn(format, ap);
+    va_end(ap);
+}
+
+void verr(int eval, const char *format, va_list ap)
+{
+    vwarn(format, ap);
+    exit(eval);
+}
+
+void err(int eval, const char *format, ...)
+{
+    va_list ap;
+    va_start(ap, format);
+    verr(eval, format, ap);
+    va_end(ap);
+}
+
+void vwarnx(const char *format, va_list ap)
+{
+    printk("stubdom: ");
+    if (format)
+        print(0, format, ap);
+}
+
+void warnx(const char *format, ...)
+{
+    va_list ap;
+    va_start(ap, format);
+    vwarnx(format, ap);
+    va_end(ap);
+}
+
+void verrx(int eval, const char *format, va_list ap)
+{
+    vwarnx(format, ap);
+    exit(eval);
+}
+
+void errx(int eval, const char *format, ...)
+{
+    va_list ap;
+    va_start(ap, format);
+    verrx(eval, format, ap);
+    va_end(ap);
+}
+
 int nanosleep(const struct timespec *req, struct timespec *rem)
 {
     s_time_t start = NOW();
@@ -1115,47 +1220,15 @@
     } else ASSERT(0);
 }
 
-#define UNMAP_BATCH ((STACK_SIZE / 2) / sizeof(multicall_entry_t))
 int munmap(void *start, size_t length)
 {
     int total = length / PAGE_SIZE;
-    ASSERT(!((unsigned long)start & ~PAGE_MASK));
-    while (total) {
-        int n = UNMAP_BATCH;
-        if (n > total)
-            n = total;
-        {
-            int i;
-            multicall_entry_t call[n];
-            unsigned char (*data)[PAGE_SIZE] = start;
-            int ret;
-
-            for (i = 0; i < n; i++) {
-                int arg = 0;
-                call[i].op = __HYPERVISOR_update_va_mapping;
-                call[i].args[arg++] = (unsigned long) &data[i];
-                call[i].args[arg++] = 0;
-#ifdef __i386__
-                call[i].args[arg++] = 0;
-#endif
-                call[i].args[arg++] = UVMF_INVLPG;
-            }
-
-            ret = HYPERVISOR_multicall(call, n);
-            if (ret) {
-                errno = -ret;
-                return -1;
-            }
+    int ret;
 
-            for (i = 0; i < n; i++) {
-                if (call[i].result) {
-                    errno = call[i].result;
-                    return -1;
-                }
-            }
-        }
-        start = (char *)start + n * PAGE_SIZE;
-        total -= n;
+    ret = unmap_frames((unsigned long)start, (unsigned long)total);
+    if (ret) {
+        errno = ret;
+        return -1;
     }
     return 0;
 }
@@ -1232,6 +1305,13 @@
 unsupported_function_crash(sysconf);
 unsupported_function(int, tcsetattr, -1);
 unsupported_function(int, tcgetattr, 0);
+unsupported_function(int, poll, -1);
+
+/* net/if.h */
+unsupported_function_log(unsigned int, if_nametoindex, -1);
+unsupported_function_log(char *, if_indextoname, (char *) NULL);
+unsupported_function_log(struct  if_nameindex *, if_nameindex, (struct  if_nameindex *) NULL);
+unsupported_function_crash(if_freenameindex);
 
 /* Linuxish abi for the Caml runtime, don't support */
 unsupported_function_log(struct dirent *, readdir64, NULL);
diff -Nur ../extras/mini-os/minios.mk /root/extras/mini-os/minios.mk
--- ../extras/mini-os/minios.mk	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/minios.mk	2009-06-04 22:55:12.000000000 +0800
@@ -26,6 +26,9 @@
 DEF_CFLAGS += -O3
 endif
 
+# Make the headers define our internal stuff
+DEF_CFLAGS += -D__INSIDE_MINIOS__
+
 # Build the CFLAGS and ASFLAGS for compiling and assembling.
 # DEF_... flags are the common mini-os flags,
 # ARCH_... flags may be defined in arch/$(TARGET_ARCH_FAM/rules.mk
diff -Nur ../extras/mini-os/netfront.c /root/extras/mini-os/netfront.c
--- ../extras/mini-os/netfront.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/netfront.c	2009-06-04 22:55:12.000000000 +0800
@@ -306,11 +306,16 @@
     int retry=0;
     int i;
     char* msg;
-    char* nodename = _nodename ? _nodename : "device/vif/0";
-
+    char nodename[256];
+    char path[256];
     struct netfront_dev *dev;
+    static int netfrontends = 0;
 
-    char path[strlen(nodename) + 1 + 10 + 1];
+    if (!_nodename)
+        snprintf(nodename, sizeof(nodename), "device/vif/%d", netfrontends);
+    else
+        strncpy(nodename, _nodename, strlen(nodename));
+    netfrontends++;
 
     if (!thenetif_rx)
 	thenetif_rx = netif_rx;
diff -Nur ../extras/mini-os/sched.c /root/extras/mini-os/sched.c
--- ../extras/mini-os/sched.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/sched.c	2009-06-19 16:31:52.000000000 +0800
@@ -59,6 +59,7 @@
 static int threads_started;
 
 struct thread *main_thread;
+static int globe_tid;
 
 void inline print_runqueue(void)
 {
@@ -67,9 +68,21 @@
     minios_list_for_each(it, &idle_thread->thread_list)
     {
         th = minios_list_entry(it, struct thread, thread_list);
-        printk("   Thread \"%s\", runnable=%d\n", th->name, is_runnable(th));
+        printk("Thread_name= %s		Thread_id= %d		runnable= %d\n", th->name, th->tid,is_runnable(th));
     }
-    printk("\n");
+}
+
+struct thread *get_thread_byid(int tid)
+{
+	struct minios_list_head *it;
+	struct thread *th;
+	minios_list_for_each(it, &idle_thread->thread_list)
+	{
+		th = minios_list_entry(it, struct thread, thread_list);
+		if(th->tid == tid)
+			return th;
+	}
+	return NULL;
 }
 
 void schedule(void)
@@ -135,6 +148,7 @@
         {
             minios_list_del(&thread->thread_list);
             free_pages(thread->stack, STACK_SIZE_PAGE_ORDER);
+	    xfree(thread->name);
             xfree(thread);
         }
     }
@@ -148,11 +162,13 @@
     thread = arch_create_thread(name, function, data);
     /* Not runable, not exited, not sleeping */
     thread->flags = 0;
+    thread->tid = ++globe_tid;
     thread->wakeup_time = 0LL;
 #ifdef HAVE_LIBC
     _REENT_INIT_PTR((&thread->reent))
 #endif
     set_runnable(thread);
+    set_alive(thread);
     local_irq_save(flags);
     if(idle_thread != NULL) {
         minios_list_add_tail(&thread->thread_list, &idle_thread->thread_list); 
@@ -205,11 +221,13 @@
 {
     unsigned long flags;
     struct thread *thread = current;
+   // printk("The address of current thread is 0x%llx	size is %d\n",thread->name ,sizeof(struct thread));
     printk("Thread \"%s\" exited.\n", thread->name);
     local_irq_save(flags);
     /* Remove from the thread list */
     minios_list_del(&thread->thread_list);
     clear_runnable(thread);
+    clear_alive(thread);
     /* Put onto exited list */
     minios_list_add(&thread->thread_list, &exited_threads);
     local_irq_restore(flags);
diff -Nur ../extras/mini-os/xenbus/xenbus.c /root/extras/mini-os/xenbus/xenbus.c
--- ../extras/mini-os/xenbus/xenbus.c	2009-06-19 16:51:24.000000000 +0800
+++ /root/extras/mini-os/xenbus/xenbus.c	2009-06-04 22:55:12.000000000 +0800
@@ -633,7 +633,7 @@
     return NULL;
 }
 
-int xenbus_read_integer(char *path)
+int xenbus_read_integer(const char *path)
 {
     char *res, *buf;
     int t;
@@ -650,8 +650,8 @@
 }
 
 char* xenbus_printf(xenbus_transaction_t xbt,
-                                  char* node, char* path,
-                                  char* fmt, ...)
+                                  const char* node, const char* path,
+                                  const char* fmt, ...)
 {
 #define BUFFER_SIZE 256
     char fullpath[BUFFER_SIZE];
@@ -666,6 +666,17 @@
     return xenbus_write(xbt,fullpath,val);
 }
 
+domid_t xenbus_get_self_id(void)
+{
+    char *dom_id;
+    domid_t ret;
+
+    BUG_ON(xenbus_read(XBT_NIL, "domid", &dom_id));
+    sscanf(dom_id, "%d", &ret);
+
+    return ret;
+}
+
 static void do_ls_test(const char *pre)
 {
     char **dirs, *msg;
